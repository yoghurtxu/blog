<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA['test']]></title>
    <url>%2F2020%2F05%2F09%2Ftest%2F</url>
    <content type="text"></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>LHS和RHS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue数据劫持]]></title>
    <url>%2F2019%2F09%2F16%2Fvue%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[vue3.0怎么实现数据劫持的什么是数据劫持数据劫持通常我们利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。 数据劫持的优势 不用复杂的调用 可以得知变化的数据 首先我们看下2.x用Object.defineProperty实现的简单的双向绑定 123456789101112131415const obj = &#123;&#125;;Object.defineProperty(obj, 'text', &#123; get: function() &#123; console.log('get val'); &#125;, set: function(newVal) &#123; console.log('set val:'+newVal) document.getElementById('input').value = newVal; document.getElementById('span').innerHTML = newVal; &#125;&#125;);const oinput = document.getElementById('input');oinput.addEventListener('keyup', function(e)&#123; obj.text = e.target.value; &#125;) Vue2.x的缺陷属性值改为数组就无法监听数组变化 尤大神用了一些奇技淫巧,把无法监听数组的情况hack掉了 123456789101112131415161718192021const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];const arrayAugmentations = [];aryMethods.forEach((method)=&gt; &#123; // 这里是原生Array的原型方法 let original = Array.prototype[method]; // 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上 // 注意：是属性而非原型属性 arrayAugmentations[method] = function () &#123; console.log('我被改变啦!'); // 调用对应的原生方法并返回结果 return original.apply(this, arguments); &#125;;&#125;);let list = ['a', 'b', 'c'];// 将我们要监听的数组的原型指针指向上面定义的空数组对象// 别忘了这个空数组的属性上定义了我们封装好的push等方法list.__proto__ = arrayAugmentations;list.push('d'); // 我被改变啦！ 4// 这里的list2没有被重新定义原型指针，所以就正常输出let list2 = ['a', 'b', 'c'];list2.push('d'); // 4 只能劫持对象的属性假如需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 Vue3.x的特点带着以上缺点我们看下3.x版本怎么实现数据劫持 3.x版本中把Object.defineProperty换成Proxy Proxy在ES6规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy是Object.defineProperty的全方位加强版 如果对Proxy属性还不是很了解的小伙伴 可以翻阅下Es6官方文档 Proxy可以直接监听数组的变化123456789101112131415161718192021222324252627282930313233343536373839404142434445const olist = document.getElementById('list');const obtn = document.getElementById('btn');// 渲染列表const Render = &#123; // 初始化 init: function(arr) &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) &#123; const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); &#125; olist.appendChild(fragment); &#125;, // 我们只考虑了增加的情况,仅作为示例 change: function(val) &#123; const li = document.createElement('li'); li.textContent = val; olist.appendChild(li); &#125;,&#125;;// 初始数组const arr = [1, 2, 3, 4];// 监听数组const newArr = new Proxy(arr, &#123; get: function(target, key, receiver) &#123; console.log(key); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key !== 'length') &#123; Render.change(value); &#125; return Reflect.set(target, key, value, receiver); &#125;,&#125;);// 初始化window.onload = function() &#123; Render.init(arr);&#125;// push数字obtn.addEventListener('click', function() &#123; newArr.push(6);&#125;); Proxy可以直接监听对象而非属性1234567891011121314151617181920const input = document.getElementById('input');const p = document.getElementById('p');const obj = &#123;&#125;;const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key === 'text') &#123; input.value = value; p.innerHTML = value; &#125; return Reflect.set(target, key, value, receiver); &#125;,&#125;);input.addEventListener('keyup', function(e) &#123; newObj.text = e.target.value;&#125;); 总结Proxy特点: 可以劫持整个对象，并返回一个新对象 有13种劫持操作 Proxy是es6提供的，兼容性不好,无法用polyfill磨平 友情提示:目标对象内部的this关键字会指向 Proxy 代理]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>数据劫持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular脏值检测]]></title>
    <url>%2F2019%2F09%2F16%2Fangular%E8%84%8F%E5%80%BC%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[一: 概念简介 脏值检测，简单的说就是在MVC的构架中，视图会通过模型的change事件来更新自己。 脏值检测的核心代码是观察者模式的实现，其机制会执行digest循环，在特定UI组件的上下文执行注册的各种表达式。 那么脏值检测在单页应用扮演了什么角色呢？ 为了支持单页SPA应用，angular1引入了指令的概念，能够扩展HTML标签并且封装相关的DOM逻辑，以此来构建组件，组件再组合成一个个网页。angular2也保留了指令的概念。那么angular2和1版本的区别在哪里呢？angular2的指令则是简化版的指令API，能通过属性型的指令给DOM标签添加行为。 而与此同时，组件则可以看做指令API的补充，既可以添加模板，也可以添加行为，组件继承自指令。 123456@Directive(&#123; selector: &apos;[saTooltip]&apos;&#125;)export class Tooltip &#123; //略&#125; 二: angular1中的脏值检测ch4-change-detection/angular1-demo/index.html: ;) 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt; &lt;!--引入版本为1.5.0--&gt; &lt;script&gt; angular.module(&quot;app&quot;,[]) .controller(&quot;mainCtrl&quot;,function($scope)&#123; $scope.label=&quot;hello world!&quot;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;app&quot; ng-controller=&quot;mainCtrl&quot;&gt; &lt;div&gt; &lt;span&gt;label值:&#123;&#123;label&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;input type=&quot;text&quot; ng-model=&quot;label&quot;/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ;) 浏览器结果 angular1的数据绑定，酷炫而神秘！可是它幕后实际发生了什么呢？ (1)首先，在指令ng-model和双大括号(实际上是ng-bind指令)内部绑定了多个watcher(监视器)。 (2)接下来，当指定的事件发生之后，angular循环遍历所有的监视器，并执行对应scope上下文的表达式。这里就是digest循环。 (3)最后，比对两次结果，如果不相同就调用回调函数。 但这种发生特定事件(有可能在框架管理范围内，也可能在范围外部)会调用digest循环有缺点。比如回调函数有setTimeOut定时器，定时器把绑定到Scope上的属性给修改了，那么angular就无法察觉对象的改变了。angular2解决这个问题。 二: angular2更优的脏值检测1.zone.js库 zone.js是angular2的一个库，可以在javascript实现各种分区。分区代表一个执行上下文。angular2利用了zone.js来拦截浏览器中的各种异步事件，然后在正确的时机调用digest循环，完全消除了需要angular开发者显式调用digest循环的情况。 2.单向数据流 在第一章的例子里，label表达式在ng-model指令下发生改变，也会通知label的双大括号表达式改变值，这隐含了指令之间互相影响、有依赖关系。跨监视器的依赖会创建出各种纠缠不清的额数据流，导致最后可能很难追踪，进而导致难以预料的错误。 angular2保留了脏值检测的概念用来检测数据，但强制使用了单向数据流。 实现的方式: 禁止不同的监视器互相依赖，digest循环只要运行一次就好了。 单向数据流好处不仅仅于此，更简单的数据流，而且性能提高了 3.增强angular1的脏值检测 我们说到digest循环有比较的步骤，比较操作的最佳算法是根据表达式返回值的类型进行比较。angular1有的是浅比较，有的是深比较，而且开发者并不能自己预先决定使用哪种比较。angular2团队把比较功能分离到了differ(差异比较器)中，那么开发者就可以通过2个基础类扩展自定义算法了，从而有了对脏值检测机制的完全控制。 ●KeyValueDiffer。键值对型差异比较器。 ●IterableDiffer。迭代型差异比较器。]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>脏值检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读webpack的bundle.js]]></title>
    <url>%2F2019%2F09%2F16%2F%E8%A7%A3%E8%AF%BBwebpack%E7%9A%84bundle%2F</url>
    <content type="text"><![CDATA[可能就是好奇心略重了，读了一下webpack打包后的bundle.js的代码，复杂的模块可能读不懂，但简单的hello world模块我还是能看懂的。没什么目的，就是想通过几个简单的模块，一条简单的webpack命令，一个神奇的bundle.js代码来了解webpack是怎么把遵循commonJs规范的模块应用到浏览器端的。 几个简单的模块： 一条简单的webpack命令： 一个神奇的bundle.js： View Code 注释太多有点懵逼，可是细看也不就是一个立即执行的函数表达式嘛（IIFE），这是JavaScript中常见的独立作用域的方法。这里我将注释简化一下： ;) 1234567891011121314151617181920212223242526272829303132333435363738 1 (function(modules)&#123; 2 //module缓存对象 3 var installedModules = &#123;&#125;; 4 //require函数 5 function __webpack_require__(moduleId)&#123; 6 //检查module是否在cache中 7 if(installedModules[moduleId])&#123; 8 return installedModules[moduleId].exports; 9 &#125;10 //若不在cache中则新建module并放入cache中11 var module = installedModules[moduleId] = &#123;12 exports: &#123;&#125;,13 id: moduleId,14 loaded: false15 &#125;;16 //执行module函数17 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);18 //标记module已经加载19 module.loaded = true;20 //返回module的导出模块21 return module.exports;22 &#125;23 24 //暴露modules对象（__webpack_modules__）25 __webpack_require__.m = modules;26 //暴露modules缓存27 __webpack_require__.c = installedModules;28 //设置webpack公共路径__webpack_public_path__29 __webpack_require__.p = &quot;&quot;;30 //读取入口模块并且返回exports导出31 return __webpack_require__(0);32 33 &#125;)([function(module, exports, __webpack_require__)&#123; /*模块Id为0*/34 var text = __webpack_require__(1);35 console.log(text);36 &#125;,function(module, exports)&#123; /*模块Id为1*/37 module.exports = &apos;Hello world&apos;;38 &#125;]); ;) 这个IIFE接收一个数组作为参数modules，数组的每一项都是一个匿名函数代表一个模块（index.js和hello.js模块）。可是为什么构建命令中只出现了“index.js”呢，这是因为webpack通过静态分析index.js文件得到语法树，递归检测index.js所依赖的模块，以及依赖的依赖，入口模块和所有的依赖模块作为数组中的项，并合并到最终的代码中。 正是由于模块代码被包装成函数后，每个模块的运行时机变的可控，可以决定何时调用（通过 modules[moduleId].call ），而且也有了独立的作用域，定义变量，声明函数都不会污染全局作用域。模块函数的参数列表中除了commonJS规范所要求的 module 与 exports 外，还有 webpack_require 函数，用来替换 require ，作用是声明对其他模块的依赖并获得该模块的 exports （ return installedModules[moduleId].exports 和 return module.exports; ）。而且不需要提供模块的相对路径或其他形式的ID，直接传入该模块在modules列表中索引即可，这样可以省掉模块标识符的解析过程（准确说，webpack是把require模块的解析过程提前到了构建期），从而可以获得更好的运行性能。 程序解读：bundle.js通过 webpack_require(0); 启动整个程序，先检查模块ID = 0是否在缓存对象中，若该模块的缓存存在返回 module.exports 即模块所暴露出来的数据，若该模块的缓存不在则新创建module对象（该module对象作用是用来指向真实模块）并加入到缓存对象中，此时由于module对象和该模块的缓存对象 installedModules[moduleId] 的exports属性为没有数据，所以需要通过执行该模块函数来返回具体require其他模块的数据，传入的上下文对象是 module.exports 和 installedModules[moduleId].exports 所共同指向的一个对象。当程序执行到 var text = webpack_require(1); 时，又会执行 modules[1].call ，然后 module.exports = ‘Hello world’; 将执行 webpack_require(1) 时创建的module1的exports赋值为Hello world，并返回，此时 webpack_require(1) 执行完毕，text为Hello world并打印， webpack_require(0) 执行完毕。这是一个递归的过程，如果还有更多依赖模块的话会更明显。 总结一下，webpack主要做了两部分工作：1.分析得到所有必须模块并合并。2.提供让这些模块有序，正常的执行环境。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析浏览器渲染基本原理]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[大多数设备的刷新频率是60Hz，也就说是浏览器对每一帧画面的渲染工作要在16ms内完成,超出这个时间，页面的渲染就会出现卡顿现象，影响用户体验。前端的用户体验给了前端直观的印象，因此对B/S架构的开发人员来说，熟悉浏览器的内部执行原理显得尤为重要。 1. 浏览器主要组成与浏览器线程1.1 浏览器组件浏览器大体上由以下几个组件组成，各个浏览器可能有一点不同。 界面控件 – 包括地址栏，前进后退，书签菜单等窗口上除了网页显示区域以外的部分 浏览器引擎 – 查询与操作渲染引擎的接口 渲染引擎 – 负责显示请求的内容。比如请求到HTML, 它会负责解析HTML、CSS并将结果显示到窗口中 网络 – 用于网络请求, 如HTTP请求。它包括平台无关的接口和各平台独立的实现 UI后端 – 绘制基础元件，如组合框与窗口。它提供平台无关的接口，内部使用操作系统的相应实现 JS解释器 - 用于解析执行JavaScript代码 数据存储持久层 - 浏览器需要把所有数据存到硬盘上，如cookies。新的HTML5规范规定了一个完整（虽然轻量级）的浏览器中的数据库web database 注意：chrome浏览器与其他浏览器不同，chrome使用多个渲染引擎实例，每个Tab页一个，即每个Tab都是一个独立进程。 1.2 浏览器中的进程与线程Chrome浏览器使用多个进程来隔离不同的网页，在Chrome中打开一个网页相当于起了一个进程，每个tab网页都有由其独立的渲染引擎实例。因为如果非多进程的话，如果浏览器中的一个tab网页崩溃，将会导致其他被打开的网页应用。另外相对于线程，进程之间是不共享资源和地址空间的，所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源，所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。 在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成： GUI 渲染线程GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的，也就是说被冻结了. JavaScript引擎线程JS为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JS是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS在最初就选择了单线程执行。GUI渲染线程与JS引擎线程互斥的，是由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。由于GUI渲染线程与JS执行线程是互斥的关系，当浏览器在执行JS程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 定时触发器线程浏览器定时计数器并不是由JS引擎计数的, 因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。 事件触发线程当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。 异步http请求线程在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理。 2. 渲染过程2.1 渲染流程用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。每次通常渲染不会超过8K的数据块，其中基础的渲染流程图： webkit引擎渲染的详细流程，其他引擎渲染流程稍有不同： 渲染流程有四个主要步骤： 解析HTML生成DOM树 - 渲染引擎首先解析HTML文档，生成DOM树 构建Render树 - 接下来不管是内联式，外联式还是嵌入式引入的CSS样式会被解析生成CSSOM树，根据DOM树与CSSOM树生成另外一棵用于渲染的树-渲染树(Render tree)， 布局Render树 - 然后对渲染树的每个节点进行布局处理，确定其在屏幕上的显示位置 绘制Render树 - 最后遍历渲染树并用UI后端层将每一个节点绘制出来 以上步骤是一个渐进的过程，为了提高用户体验，渲染引擎试图尽可能快的把结果显示给最终用户。它不会等到所有HTML都被解析完才创建并布局渲染树。它会在从网络层获取文档内容的同时把已经接收到的局部内容先展示出来。 2.2 渲染细节1. 生成DOM树DOM树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。DOM树的根节点就是document对象。 DOM树的生成过程中可能会被CSS和JS的加载执行阻塞，具体可以参见下一章。当HTML文档解析过程完毕后，浏览器继续进行标记为deferred模式的脚本加载，然后就是整个解析过程的实际结束触发DOMContentLoaded事件，并在async文档文档执行完之后触发load事件。 2. 生成Render树生成DOM树的同时会生成样式结构体CSSOM（CSS Object Model）Tree，再根据CSSOM和DOM树构造渲染树Render Tree，渲染树包含带有颜色，尺寸等显示属性的矩形，这些矩形的顺序与显示顺序基本一致。从MVC的角度来说，可以将Render树看成是V，DOM树与CSSOM树看成是M，C则是具体的调度者，比HTMLDocumentParser等。 可以这么说，没有DOM树就没有Render树，但是它们之间不是简单的一对一的关系。Render树是用于显示，那不可见的元素当然不会在这棵树中出现了，譬如&lt;head&gt;。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。 3. DOM树与Render树DOM对象类型很丰富，什么head、title、div，而Render树相对来说就比较单一了，毕竟它的职责就是为了以后的显示渲染用嘛。Render树的每一个节点我们叫它渲染器renderer。 一棵Render树大概是酱紫，左边是DOM树，右边是Render树： 从上图我们可以看出，renderer与DOM元素是相对应的，但并不是一一对应，有些DOM元素没有对应的renderer，而有些DOM元素却对应了好几个renderer，对应多个renderer的情况是普遍存在的，就是为了解决一个renderer描述不清楚如何显示出来的问题，譬如有下拉列表的select元素，我们就需要三个renderer：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。 另外，renderer与DOM元素的位置也可能是不一样的。那些添加了float或者position:absolute的元素，因为它们脱离了正常的文档流，构造Render树的时候会针对它们实际的位置进行构造。 4. 布局与绘制上面确定了renderer的样式规则后，然后就是重要的显示元素布局了。当renderer构造出来并添加到Render树上之后，它并没有位置跟大小信息，为它确定这些信息的过程，接下来是布局(layout)。 浏览器进行页面布局基本过程是以浏览器可见区域为画布，左上角为(0,0)基础坐标，从左到右，从上到下从DOM的根节点开始画，首先确定显示元素的大小跟位置，此过程是通过浏览器计算出来的，用户CSS中定义的量未必就是浏览器实际采用的量。如果显示元素有子元素得先去确定子元素的显示信息。 布局阶段输出的结果称为box盒模型（width,height,margin,padding,border,left,top,…），盒模型精确表示了每一个元素的位置和大小，并且所有相对度量单位此时都转化为了绝对单位。 在绘制(painting)阶段，渲染引擎会遍历Render树，并调用renderer的 paint() 方法，将renderer的内容显示在屏幕上。绘制工作是使用UI后端组件完成的。 5. 回流与重绘回流(reflow)：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。reflow 会从&lt;html&gt;这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 重绘(repaint)：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。 每次Reflow，Repaint后浏览器还需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。Reflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。可以在csstrigger上查找某个css属性会触发什么事件。 reflow与repaint的时机： display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。 有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。 3. 关键渲染路径与阻塞渲染在浏览器拿到HTML、CSS、JS等外部资源到渲染出页面的过程，有一个重要的概念关键渲染路径（Critical Rendering Path）。例如为了保障首屏内容的最快速显示，通常会提到一个渐进式页面渲染，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。了解原理可以让我们更好的优化关键渲染路径，从而获得更好的用户体验。 现代浏览器总是并行加载资源，例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。 同时，由于下面两点： CSS 被视为渲染阻塞资源(包括JS)，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕，才会进行下一阶段。 JavaScript 被认为是解释器阻塞资源，HTML解析会被JS阻塞，它不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。 存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外： 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。 JavaScript 可以查询和修改 DOM 与 CSSOM。 CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则： CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。 JavaScript 应尽量少影响 DOM 的构建。 下面来看看 CSS 与 JavaScript 是具体如何阻塞资源的。 3.1 CSS12&lt;style&gt; p &#123; color: red; &#125;&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; 这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。 渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。 最容易想到的当然是精简 CSS 并尽快提供它。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。 123&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 30em) and (orientation: landscape)&quot;&gt; 第一个资源会加载并阻塞。第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。第三个资源提供了媒体查询，会在符合条件时阻塞渲染。 关于CSS加载的阻塞情况： css加载不会阻塞DOM树的解析 css加载会阻塞DOM树的渲染 css加载会阻塞后面js语句的执行 没有js的理想情况下，html与css会并行解析，分别生成DOM与CSSOM，然后合并成Render Tree，进入Rendering Pipeline；但如果有js，css加载会阻塞后面js语句的执行，而（同步）js脚本执行会阻塞其后的DOM解析（所以通常会把css放在头部，js放在body尾） 3.2 JavaScriptJavaScript 的情况比 CSS 要更复杂一些。如果没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的HTML元素之前，也就是说不等待后续载入的HTML元素，读到就加载并执行。观察下面的代码： 123456789&lt;p&gt;Do not go gentle into that good night,&lt;/p&gt;&lt;script&gt;console.log(&quot;inline1&quot;)&lt;/script&gt;&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;p&gt;Rage, rage against the dying of the light.&lt;/p&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;&lt;script&gt;console.log(&quot;inline2&quot;)&lt;/script&gt;&lt;p&gt;Rage, rage against the dying of the light.&lt;/p&gt; 这里的 script 标签会阻塞 HTML 解析，无论是不是 inline-script。上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打断一次（加载、执行）。 解析过程中无论遇到的JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒JavaScript解析器，就会进行暂停 (blocked )浏览器解析HTML，并等到 CSSOM 构建完毕，才去执行js脚本。因为脚本中可能会操作DOM元素，而如果在加载执行脚本的时候DOM元素并没有被解析，脚本就会因为DOM元素没有生成取不到响应元素，所以实际工程中，我们常常将资源放到文档底部。 3.3 改变脚本加载次序defer与asyncdefer 与 async 可以改变之前的那些阻塞情形，这两个属性都会使 script 异步加载，然而执行的时机是不一样的。注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。 123&lt;script async&gt;console.log(&quot;1&quot;)&lt;/script&gt;&lt;script defer&gt;console.log(&quot;2&quot;)&lt;/script&gt;&lt;script&gt;console.log(&quot;3&quot;)&lt;/script&gt; 上面脚本会按需输出 1 2 3，故，下面两节讨论的内容都是针对设置了 src 属性的 script 标签。 先放个熟悉的图~ 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 defer123&lt;script src=&quot;app1.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;app2.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;app3.js&quot; defer&gt;&lt;/script&gt; defer 属性表示延迟执行引入 JavaScript，即 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，再触发DOMContentLoaded(初始的 HTML 文档被完全加载和解析完成之后触发，无需等待样式表图像和子框架的完成加载) 事件。 defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 asyncasync 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发(HTML解析完成事件)之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 从上一段也能推出，多个 async-script 的执行顺序是不确定的，谁先加载完谁执行。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true。 document.createElement使用 document.createElement 创建的 script 默认是异步的，示例如下。 1console.log(document.createElement(&quot;script&quot;).async); // true 所以，通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。如果想同步执行，需要将 async 属性人为设置为 false。 如果使用 document.createElement 创建 link 标签会怎样呢？ 1234const style = document.createElement(&quot;link&quot;);style.rel = &quot;stylesheet&quot;;style.href = &quot;index.css&quot;;document.head.appendChild(style); // 阻塞？ 其实这只能通过试验确定，已知的是，Chrome 中已经不会阻塞渲染，Firefox、IE 在以前是阻塞的，现在会怎样目前不太清楚。 4. 优化渲染性能结合渲染流程，可以针对性的优化渲染性能： 优化JS的执行效率 降低样式计算的范围和复杂度 避免大规模、复杂的布局 简化绘制的复杂度、减少绘制区域 优先使用渲染层合并属性、控制层数量 对用户输入事件的处理函数去抖动（移动设备） 这里主要参考Google的浏览器渲染性能的基础讲座，想看更详细内容可以去瞅瞅~ 4.1 优化JS的执行效率1. 动画实现使用requestAnimationFramesetTimeout(callback)和setInterval(callback)无法保证callback函数的执行时机，很可能在帧结束的时候执行，从而导致丢帧，如下图： requestAnimationFrame(callback)可以保证callback函数在每帧动画开始的时候执行。注意：jQuery3.0.0以前版本的animate函数就是用setTimeout来实现动画，可以通过jquery-requestAnimationFrame这个补丁来用requestAnimationFrame替代setTimeout 2. 长耗时的JS代码放到Web Workers中执行JS代码运行在浏览器的主线程上，与此同时，浏览器的主线程还负责样式计算、布局、绘制的工作，如果JavaScript代码运行时间过长，就会阻塞其他渲染工作，很可能会导致丢帧。前面提到每帧的渲染应该在16ms内完成，但在动画过程中，由于已经被占用了不少时间，所以JavaScript代码运行耗时应该控制在3-4毫秒。如果真的有特别耗时且不操作DOM元素的纯计算工作，可以考虑放到Web Workers中执行。 12345678910var dataSortWorker = new Worker(&quot;sort-worker.js&quot;);dataSortWorker.postMesssage(dataToSort);// 主线程不受Web Workers线程干扰dataSortWorker.addEventListener(&apos;message&apos;, function(evt) &#123; var sortedData = e.data; // Web Workers线程执行结束 // ...&#125;); 3. 拆分操作DOM元素的任务，分别在多个frame完成由于Web Workers不能操作DOM元素的限制，所以只能做一些纯计算的工作，对于很多需要操作DOM元素的逻辑，可以考虑分步处理，把任务分为若干个小任务，每个任务都放到requestAnimationFrame中回调执行 12345678910111213var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);requestAnimationFrame(processTaskList);function processTaskList(taskStartTime) &#123; var nextTask = taskList.pop(); // 执行小任务 processTask(nextTask); if (taskList.length &gt; 0) &#123; requestAnimationFrame(processTaskList); &#125;&#125; 4. 使用Chrome DevTools的Timeline来分析JavaScript的性能打开Chrome DevTools &gt; Timeline &gt; JS Profile，录制一次动作，然后分析得到的细节信息，从而发现问题并修复问题。 4.2 降低样式计算的范围和复杂度添加或移除一个DOM元素、修改元素属性和样式类、应用动画效果等操作，都会引起DOM结构的改变，从而导致浏览器要repaint或者reflow。那么这里可以采取一些措施。 1. 降低样式选择器的复杂度尽量保持class的简短，或者使用Web Components框架。 123.box:nth-last-child(-n+1) .title &#123;&#125;// 改善后.final-box-title &#123;&#125; 2. 减少需要执行样式计算的元素个数由于浏览器的优化，现代浏览器的样式计算直接对目标元素执行，而不是对整个页面执行，所以我们应该尽可能减少需要执行样式计算的元素的个数。 4.3 避免大规模、复杂的布局布局就是计算DOM元素的大小和位置的过程，如果你的页面中包含很多元素，那么计算这些元素的位置将耗费很长时间。布局的主要消耗在于：1. 需要布局的DOM元素的数量；2. 布局过程的复杂程度 1. 尽可能避免触发布局当你修改了元素的属性之后，浏览器将会检查为了使这个修改生效是否需要重新计算布局以及更新渲染树，对于DOM元素的几何属性修改，比如width/height/left/top等，都需要重新计算布局。对于不能避免的布局，可以使用Chrome DevTools工具的Timeline查看布局的耗时，以及受影响的DOM元素数量。 2. 使用flexbox替代老的布局模型老的布局模型以相对/绝对/浮动的方式将元素定位到屏幕上，而Floxbox布局模型用流式布局的方式将元素定位到屏幕上。通过一个小实验可以看出两种布局模型的性能差距，同样对1300个元素布局，浮动布局耗时14.3ms，Flexbox布局耗时3.5ms。IE10+支持。 3. 避免强制同步布局事件的发生根据渲染流程，JS脚本是在layout之前执行，但是我们可以强制浏览器在执行JS脚本之前先执行布局过程，这就是所谓的强制同步布局。 1234567891011121314151617181920requestAnimationFrame(logBoxHeight);// 先写后读，触发强制布局function logBoxHeight() &#123; // 更新box样式 box.classList.add(&apos;super-big&apos;); // 为了返回box的offersetHeight值 // 浏览器必须先应用属性修改，接着执行布局过程 console.log(box.offsetHeight);&#125;// 先读后写，避免强制布局function logBoxHeight() &#123; // 获取box.offsetHeight console.log(box.offsetHeight); // 更新box样式 box.classList.add(&apos;super-big&apos;);&#125; 在JS脚本运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧的值。因此，如果你在当前帧获取属性之前又对元素节点有改动，那就会导致浏览器必须先应用属性修改，结果执行布局过程，最后再执行JS逻辑。 4. 避免连续的强制同步布局发生如果连续快速的多次触发强制同步布局，那么结果更糟糕。比如下面的例子，获取box的属性，设置到paragraphs上，由于每次设置paragraphs都会触发样式计算和布局过程，而下一次获取box的属性必须等到上一步设置结束之后才能触发。 1234567891011121314function resizeWidth() &#123; // 会让浏览器陷入&apos;读写读写&apos;循环 for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + &apos;px&apos;; &#125;&#125;// 改善后方案var width = box.offsetWidth;function resizeWidth() &#123; for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + &apos;px&apos;; &#125;&#125; 注意：可以使用FastDOM来确保读写操作的安全，从而帮你自动完成读写操作的批处理，还能避免意外地触发强制同步布局或快速连续布局，消除大量操作DOM的时候的布局抖动。 4.4 简化绘制的复杂度、减少绘制区域Paint就是填充像素的过程，通常这个过程是整个渲染流程中耗时最长的一环，因此也是最需要避免发生的一环。如果Layout被触发，那么接下来元素的Paint一定会被触发。当然纯粹改变元素的非几何属性，也可能会触发Paint，比如背景、文字颜色、阴影效果等。 1. 提升移动或渐变元素的绘制层绘制并非总是在内存中的单层画面里完成的，实际上，浏览器在必要时会将一帧画面绘制成多层画面，然后将这若干层画面合并成一张图片显示到屏幕上。这种绘制方式的好处是，使用transform来实现移动效果的元素将会被正常绘制，同时不会触发其他元素的绘制。 2. 减少绘制区域，简化绘制的复杂度浏览器会把相邻区域的渲染任务合并在一起进行，所以需要对动画效果进行精密设计，以保证各自的绘制区域不会有太多重叠。另外可以实现同样效果的不同方式，应该采用性能更好的那种。 3. 通过Chrome DevTools来分析绘制复杂度和时间消耗，尽可能降低这些指标打开DevTools，在弹出的面板中，选中More Tools &gt; Rendering选项卡下的Paint flashing，这样每当页面发生绘制的时候，屏幕就会闪现绿色的方框。通过该工具可以检查Paint发生的区域和时机是不是可以被优化。通过Chrome DevTools中的Timeline &gt; Paint选项可以查看更细节的Paint信息 4.5 优先使用渲染层合并属性、控制层数量1. 使用transform/opacity实现动画效果使用transform/opacity实现动画效果，会跳过渲染流程的布局和绘制环节，只做渲染层的合并。 Type Func Position transform: translate(-px,-px) Scale transform: scale(-) Rotation transform: rotate(-deg) Skew transform: skew(X/Y)(-deg) Matrix transform: matrix(3d)(..) Opacity opacity: 0-1 使用transform/opacity的元素必须独占一个渲染层，所以必须提升该元素到单独的渲染层。 2. 提升动画效果中的元素应用动画效果的元素应该被提升到其自有的渲染层，但不要滥用。在页面中创建一个新的渲染层最好的方式就是使用CSS属性will-change，对于目前还不支持will-change属性、但支持创建渲染层的浏览器，可以通过3D transform属性来强制浏览器创建一个新的渲染层。需要注意的是，不要创建过多的渲染层，这意味着新的内存分配和更复杂的层管理。注意，IE11，Edge17都不支持这一属性。 1234.moving-element &#123; will-change: transform; transform: translateZ(0);&#125; 3. 管理渲染层、避免过多数量的层尽管提升渲染层看起来很诱人，但不能滥用，因为更多的渲染层意味着更多的额外的内存和管理资源，所以当且仅当需要的时候才为元素创建渲染层。 1234* &#123; will-change: transform; transform: translateZ(0);&#125; 4. 使用Chrome DevTools来了解页面的渲染层情况开启Timeline &gt; Paint选项，然后录制一段时间的操作，选择单独的帧，看到每个帧的渲染细节，在ESC弹出框有个Layers选项，可以看到渲染层的细节，有多少渲染层，为何被创建？ 4.6 对用户输入事件的处理函数去抖动（移动设备）用户输入事件处理函数会在运行时阻塞帧的渲染，并且会导致额外的布局发生。 1. 避免使用运行时间过长的输入事件处理函数理想情况下，当用户和页面交互，页面的渲染层合并线程将接收到这个事件并移动元素。这个响应过程是不需要主线程参与，不会导致JavaScript、布局和绘制过程发生。但是如果被触摸的元素绑定了输入事件处理函数，比如touchstart/touchmove/touchend，那么渲染层合并线程必须等待这些被绑定的处理函数执行完毕才能执行，也就是用户的滚动页面操作被阻塞了，表现出的行为就是滚动出现延迟或者卡顿。 简而言之就是你必须确保用户输入事件绑定的任何处理函数都能够快速的执行完毕，以便腾出时间来让渲染层合并线程完成他的工作。 2. 避免在输入事件处理函数中修改样式属性输入事件处理函数，比如scroll/touch事件的处理，都会在requestAnimationFrame之前被调用执行。因此，如果你在上述输入事件的处理函数中做了修改样式属性的操作，那么这些操作就会被浏览器暂存起来，然后在调用requestAnimationFrame的时候，如果你在一开始就做了读取样式属性的操作，那么将会触发浏览器的强制同步布局操作。 3. 对滚动事件处理函数去抖动通过requestAnimationFrame可以对样式修改操作去抖动，同时也可以使你的事件处理函数变得更轻 12345678910111213function onScroll(evt) &#123; // Store the scroll value for laterz. lastScrollY = window.scrollY; // Prevent multiple rAF callbacks. if (scheduledAnimationFrame) &#123; return; &#125; scheduledAnimationFrame = true; requestAnimationFrame(readAndUpdatePage);&#125;window.addEventListener(&apos;scroll&apos;, onScroll);]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的LHS和RHS查询]]></title>
    <url>%2F2019%2F09%2F16%2FJavaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[问题来源于《你不知道的JavaScript（上卷）》，文章部分论述截自原书。 简述编译原理JavaScript通常会被归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统上进行移植。 在传统编译语言的流程中，程序中的一段源代码在执行前会经历三个步骤，统称为“编译”。 分词 / 词法分析 解析 / 语法分析 代码生成 与其他语言不同，JavaScript的编译过程不是发生在构建之前的。对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。 举个栗子，var a = 2; JavaScript引擎会将它分为几步完成呢？ 答案是两步，JavaScript 会将其看成两句声明：var a; 和 a = 2;。第一个定义声明在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。 下面是原书对这句声明的拆解分析： 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在引用域中查找该变量，如果能够找到就会对它赋值。 而要讲的LHS 和 RHS 就是上面说的对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行。 LHS 和 RHSLHS(Left-hand Side)引用和RHS(Right-hand Side)引用。通常是指等号（赋值运算）的左右边的引用。我们来看下面这句代码： 1console.log(a); 这里对a的引用是一个RHS引用，因为这里a并没有赋予任何值，我们只是想查找并取得a的值，然后将它打印出来。 1a = 2; 这里对a的引用是一个LHS引用，因为我们并不关心当前的值是什么，只是想要为赋值操作找到目标。 注：LHS和RHS的含义是“赋值操作的左侧和右侧”并不一定意味这就是”=”的左侧和右侧。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。 这里再举一个较复杂的例子：（找出所有的LHS查询和所有的RHS查询） 12345function foo(a) &#123;var b = a;return a + b;&#125;var c = foo(2); 这里一共有3个LHS查询和4个RHS查询，这里我们都来做个分析。 LHS： 第6行的 c = ...，c 在赋值操作的左边，所以对 c 需要 LHS 查询。 隐藏着的 a = 2（隐式变量分配）,在调用 foo(2) 时，需要将实参2赋值给形参a，所以对 a 需要 LHS 查询。 第2行的b = ..., 解释同 1。 RHS： 第6行的 c = foo(2)，foo(2) 在赋值操作的右边，需要知道 foo(2)的值，对 foo(2) 需要 RHS 查询。 第2行的b = a， a 在赋值操作的右边，需要知道 a的值，对 a 需要 RHS 查询。 第3行的 reutrn a + b;， 需要知道 a 和 b 的值， 分别对 a 和 b 都进行 RHS 查询。 小结：如果查找的目的是对变量进行赋值，那么就会使用LHS查询； 如果目的是获取变量的值，就会使用RHS查询。 区分 LHS 和 RHS 的重要性 因为在变量还没有声明(在任何作用域中都无法找到该变量)情况下，这两种查询行为是不一样的。 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说他们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一次作用域，最后抵达全局作用域，无论找到或没找到都将停止。 借用书中的一张图，将作用域链比喻成一个建筑，在对上面的论述进行一次转换。 （对作用域链的具体介绍可以移步 理解 JavaScript 的作用域链） 这个建筑代表储蓄中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所在的位置。建筑的顶层代表全局作用域。 LHS 和 RHS 引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。 总结:不成功的RHS引用会导致抛出 ReferenceError 异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>LHS和RHS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop]]></title>
    <url>%2F2019%2F09%2F16%2Fevent_loop%2F</url>
    <content type="text"><![CDATA[前言Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。 堆，栈、队列 堆（Heap）堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种为最大堆，一种为最小堆，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 堆是线性数据结构，相当于一维数组，有唯一后继。 如最大堆 栈（Stack）栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。 栈是只能在某一端插入和删除的特殊线性表。 队列（Queue）特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。 进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为空队列。 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out） Event Loop在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。 MacroTask（宏任务） script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。 MicroTask（微任务） Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver（具体使用方式查看这里） 浏览器中的Event LoopJavascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 JS调用栈JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 同步任务和异步任务Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 任务队列Task Queue 事件循环的进程模型 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。 将事件循环中的任务设置为已选择任务。 执行任务。 将事件循环中当前运行任务设置为null。 将已经运行完成的任务从任务队列中删除。 microtasks步骤：进入microtask检查点。 更新界面渲染。 返回第一步。 执行进入microtask检查点时，用户代理会执行以下步骤： 设置microtask检查点标志为true。 当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。 清理IndexDB事务 设置进入microtask检查点的标志为false。 上述可能不太好理解，下图是我做的一张图片。 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。 每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。 举个例子12345678910111213console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;);复制代码 首先我们划分几个分类： 第一次执行：1234567Tasks：run script、 setTimeout callbackMicrotasks：Promise then JS stack: script Log: script start、script end。复制代码 执行同步代码，将宏任务（Tasks）和微任务(Microtasks)划分到各自队列中。 第二次执行：1234567Tasks：run script、 setTimeout callbackMicrotasks：Promise2 then JS stack: Promise2 callback Log: script start、script end、promise1、promise2复制代码 执行宏任务后，检测到微任务(Microtasks)队列中不为空，执行Promise1，执行完成Promise1后，调用Promise2.then，放入微任务(Microtasks)队列中，再执行Promise2.then。 第三次执行：1234567Tasks：setTimeout callbackMicrotasks： JS stack: setTimeout callbackLog: script start、script end、promise1、promise2、setTimeout复制代码 当微任务(Microtasks)队列中为空时，执行宏任务（Tasks），执行setTimeout callback，打印日志。 第四次执行：1234567Tasks：setTimeout callbackMicrotasks： JS stack: Log: script start、script end、promise1、promise2、setTimeout复制代码 清空Tasks队列和JS stack。 以上执行帧动画可以查看Tasks, microtasks, queues and schedules 或许这张图也更好理解些。 再举个例子12345678910111213141516171819202122232425262728console.log(&apos;script start&apos;)async function async1() &#123; await async2() console.log(&apos;async1 end&apos;)&#125;async function async2() &#123; console.log(&apos;async2 end&apos;) &#125;async1()setTimeout(function() &#123; console.log(&apos;setTimeout&apos;)&#125;, 0)new Promise(resolve =&gt; &#123; console.log(&apos;Promise&apos;) resolve()&#125;) .then(function() &#123; console.log(&apos;promise1&apos;) &#125;) .then(function() &#123; console.log(&apos;promise2&apos;) &#125;)console.log(&apos;script end&apos;)复制代码 这里需要先理解async/await。 async/await 在底层转换成了 promise 和 then 回调函数。 也就是说，这是 promise 的语法糖。 每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。 async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。 关于73以下版本和73版本的区别 在老版本版本以下，先执行promise1和promise2，再执行async1。 在73版本，先执行async1再执行promise1和promise2。 主要原因是因为在谷歌(金丝雀)73版本中更改了规范，如下图所示： 区别在于RESOLVE(thenable)和之间的区别Promise.resolve(thenable)。 在老版本中 首先，传递给 await 的值被包裹在一个 Promise 中。然后，处理程序附加到这个包装的 Promise，以便在 Promise 变为 fulfilled 后恢复该函数，并且暂停执行异步函数，一旦 promise 变为 fulfilled，恢复异步函数的执行。 每个 await 引擎必须创建两个额外的 Promise（即使右侧已经是一个 Promise）并且它需要至少三个 microtask 队列 ticks（tick为系统的相对时间单位，也被称为系统的时基，来源于定时器的周期性中断（输出脉冲），一次中断表示一个tick，也被称做一个“时钟滴答”、时标。）。 引用贺老师知乎上的一个例子12345async function f() &#123; await p console.log(&apos;ok&apos;)&#125;复制代码 简化理解为： 123456function f() &#123; return RESOLVE(p).then(() =&gt; &#123; console.log(&apos;ok&apos;) &#125;)&#125;复制代码 如果 RESOLVE(p) 对于 p 为 promise 直接返回 p 的话，那么 p的 then 方法就会被马上调用，其回调就立即进入 job 队列。 而如果 RESOLVE(p) 严格按照标准，应该是产生一个新的 promise，尽管该 promise确定会 resolve 为 p，但这个过程本身是异步的，也就是现在进入 job 队列的是新 promise 的 resolve过程，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了。 谷歌（金丝雀）73版本中 使用对PromiseResolve的调用来更改await的语义，以减少在公共awaitPromise情况下的转换次数。 如果传递给 await 的值已经是一个 Promise，那么这种优化避免了再次创建 Promise 包装器，在这种情况下，我们从最少三个 microtick 到只有一个 microtick。 详细过程：73以下版本 首先，打印script start，调用async1()时，返回一个Promise，所以打印出来async2 end。 每个 await，会新产生一个promise,但这个过程本身是异步的，所以该await后面不会立即调用。 继续执行同步代码，打印Promise和script end，将then函数放入微任务队列中等待执行。 同步执行完成之后，检查微任务队列是否为null，然后按照先入先出规则，依次执行。 然后先执行打印promise1,此时then的回调函数返回undefinde，此时又有then的链式调用，又放入微任务队列中，再次打印promise2。 再回到await的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，打印async1 end。 当微任务队列为空时，执行宏任务,打印setTimeout。 谷歌（金丝雀73版本） 如果传递给 await 的值已经是一个 Promise，那么这种优化避免了再次创建 Promise 包装器，在这种情况下，我们从最少三个 microtick 到只有一个 microtick。 引擎不再需要为 await 创造 throwaway Promise - 在绝大部分时间。 现在 promise 指向了同一个 Promise，所以这个步骤什么也不需要做。然后引擎继续像以前一样，创建 throwaway Promise，安排 PromiseReactionJob 在 microtask 队列的下一个 tick 上恢复异步函数，暂停执行该函数，然后返回给调用者。 具体详情查看（这里）。 NodeJS的Event Loop Node中的Event Loop是基于libuv实现的，而libuv是 Node 的新跨平台抽象层，libuv使用异步，事件驱动的编程方式，核心是提供i/o的事件循环和异步回调。libuv的API包含有时间，非阻塞的网络，异步文件操作，子进程等等。 Event Loop就是在libuv中实现的。 Node的Event loop一共分为6个阶段，每个细节具体如下： timers: 执行setTimeout和setInterval中到期的callback。 pending callback: 上一轮循环中少数的callback会放在这一阶段执行。 idle, prepare: 仅在内部使用。 poll: 最重要的阶段，执行pending callback，在适当的情况下回阻塞在这个阶段。 check: 执行setImmediate(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数)的callback。 close callbacks: 执行close事件的callback，例如socket.on(&#39;close&#39;[,fn])或者http.server.on(&#39;close, fn)。 具体细节如下： timers执行setTimeout和setInterval中到期的callback，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行callback回调，但是由于system的调度可能会延时，达不到预期时间。 以下是官网文档解释的例子： 1234567891011121314151617181920212223242526const fs = require(&apos;fs&apos;);function someAsyncOperation(callback) &#123; // Assume this takes 95ms to complete fs.readFile(&apos;/path/to/file&apos;, callback);&#125;const timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);&#125;, 100);// do someAsyncOperation which takes 95 ms to completesomeAsyncOperation(() =&gt; &#123; const startCallback = Date.now(); // do something that will take 10ms... while (Date.now() - startCallback &lt; 10) &#123; // do nothing &#125;&#125;);复制代码 当进入事件循环时，它有一个空队列（fs.readFile()尚未完成），因此定时器将等待剩余毫秒数，当到达95ms时，fs.readFile()完成读取文件并且其完成需要10毫秒的回调被添加到轮询队列并执行。 当回调结束时，队列中不再有回调，因此事件循环将看到已达到最快定时器的阈值，然后回到timers阶段以执行定时器的回调。 在此示例中，您将看到正在调度的计时器与正在执行的回调之间的总延迟将为105毫秒。 以下是我测试时间： pending callbacks此阶段执行某些系统操作（例如TCP错误类型）的回调。 例如，如果TCP socket ECONNREFUSED在尝试connect时receives，则某些* nix系统希望等待报告错误。 这将在pending callbacks阶段执行。 poll该poll阶段有两个主要功能： 执行I/O回调。 处理轮询队列中的事件。 当事件循环进入poll阶段并且在timers中没有可以执行定时器时，将发生以下两种情况之一 如果poll队列不为空，则事件循环将遍历其同步执行它们的callback队列，直到队列为空，或者达到system-dependent（系统相关限制）。 如果poll队列为空，则会发生以下两种情况之一 如果有setImmediate()回调需要执行，则会立即停止执行poll阶段并进入执行check阶段以执行回调。 如果没有setImmediate()回到需要执行，poll阶段将等待callback被添加到队列中，然后立即执行。 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。 check此阶段允许人员在poll阶段完成后立即执行回调。 如果poll阶段闲置并且script已排队setImmediate()，则事件循环到达check阶段执行而不是继续等待。 setImmediate()实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它使用libuv API来调度在poll阶段完成后执行的回调。 通常，当代码被执行时，事件循环最终将达到poll阶段，它将等待传入连接，请求等。 但是，如果已经调度了回调setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达check阶段，而不是等待poll事件。 123456789101112131415161718console.log(&apos;start&apos;)setTimeout(() =&gt; &#123; console.log(&apos;timer1&apos;) Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;) &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log(&apos;timer2&apos;) Promise.resolve().then(function() &#123; console.log(&apos;promise2&apos;) &#125;)&#125;, 0)Promise.resolve().then(function() &#123; console.log(&apos;promise3&apos;)&#125;)console.log(&apos;end&apos;)复制代码 如果node版本为v11.x， 其结果与浏览器一致。 123456789startendpromise3timer1promise1timer2promise2复制代码 具体详情可以查看《又被node的eventloop坑了，这次是node的锅》。 如果v10版本上述结果存在两种情况： 如果time2定时器已经在执行队列中了 12345678startendpromise3timer1timer2promise1promise2复制代码 如果time2定时器没有在执行对列中，执行结果为 12345678startendpromise3timer1promise1timer2promise2复制代码 具体情况可以参考poll阶段的两种情况。 从下图可能更好理解： setImmediate() 的setTimeout()的区别setImmediate和setTimeout()是相似的，但根据它们被调用的时间以不同的方式表现。 setImmediate()设计用于在当前poll阶段完成后check阶段执行脚本 。 setTimeout() 安排在经过最小（ms）后运行的脚本，在timers阶段执行。 举个例子12345678setTimeout(() =&gt; &#123; console.log(&apos;timeout&apos;);&#125;, 0);setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;);&#125;);复制代码 执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。 其结果也不一致 如果在I / O周期内移动两个调用，则始终首先执行立即回调： 1234567891011const fs = require(&apos;fs&apos;);fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;timeout&apos;); &#125;, 0); setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;); &#125;);&#125;);复制代码 其结果可以确定一定是immediate =&gt; timeout。 主要原因是在I/O阶段读取文件后，事件循环会先进入poll阶段，发现有setImmediate需要执行，会立即进入check阶段执行setImmediate的回调。 然后再进入timers阶段，执行setTimeout，打印timeout。 12345678910111213141516171819 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘复制代码 Process.nextTick()process.nextTick()虽然它是异步API的一部分，但未在图中显示。这是因为process.nextTick()从技术上讲，它不是事件循环的一部分。 process.nextTick()方法将 callback 添加到next tick队列。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用。 换种理解方式： 当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 例子12345678910111213141516171819let bar;setTimeout(() =&gt; &#123; console.log(&apos;setTimeout&apos;);&#125;, 0)setImmediate(() =&gt; &#123; console.log(&apos;setImmediate&apos;);&#125;)function someAsyncApiCall(callback) &#123; process.nextTick(callback);&#125;someAsyncApiCall(() =&gt; &#123; console.log(&apos;bar&apos;, bar); // 1&#125;);bar = 1;复制代码 在NodeV10中上述代码执行可能有两种答案，一种为： 1234bar 1setTimeoutsetImmediate复制代码 另一种为： 1234bar 1setImmediatesetTimeout复制代码 无论哪种，始终都是先执行process.nextTick(callback)，打印bar 1。 转自链接：https://juejin.im/post/5c3d8956e51d4511dc72c200]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈setTimeout的作用域以及this的指向问题]]></title>
    <url>%2F2019%2F09%2F16%2F%E8%B0%88%E8%B0%88setTimeout%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8Athis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[setTimeout的常见用法是让某个方法延迟执行。我们知道，setTimeout方法是挂在window对象下的。《JavaScript高级程序设计》第二版中，写到：“超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined”。在这里，我们只讨论非严格模式。 setTimeout接受两个参数，第一个是要执行的代码或函数，第二个是延迟的时间。 一、先说结论：setTimeout中所执行函数中的this，永远指向window！！注意是要延迟执行的函数中的this哦！！ 直接使用，代码1.1： 1setTimeout("alert(this)", 1);// [object Window] 在一个对象中调用setTimeout试试，代码1.2： 123456var obj = &#123; say: function () &#123; setTimeout("alert('in obj ' + this)", 0) &#125; &#125; obj.say(); // in obj [object Window] 将执行的代码换成匿名函数试试，代码1.3： 12345678varobj = &#123; say: function () &#123; setTimeout(function () &#123; alert(this) &#125;, 0) &#125; &#125; obj.say(); // [object Window] 换成函数引用再试试吧，代码1.4： 123456789function talk() &#123; alert(this);&#125;var obj = &#123; say: function() &#123; setTimeout(talk, 0) &#125;&#125;obj.say(); // [object Window] 恩，貌似得到的结论是正确的，setTimeout中的延迟执行函数中的this指向了window。这里我反复的强调，是延迟执行函数中的this，是因为，我们经常会面对两个this。一个是setTimeout调用环境中的this，一个就是延迟执行函数中的this。这两个this有时候是不同的。有些不放心？？再多写一些代码测试一下！ 二、setTimeout中的两个this到底指向谁？？为了便于区分，我们把setTimeout调用环境下的this称之为第一个this，把延迟执行函数中的this称之为第二个this，并在代码注释中标出来，方便您区分。先说得出的结论：第一个this的指向是需要根据上下文来确定的，默认为window；第二个this就是指向window。然后我们通过代码来验证下。 函数作为方法调用还是构造函数调用，this是不同的。先看代码，代码2.1： 12345678910function Foo() &#123; this.value = 42; this.method = function() &#123; // this 指向全局对象 alert(this) // 输出window 第二个this alert(this.value); // 输出：undefined 第二个this &#125;; setTimeout(this.method, 500); // this指向Foo的实例对象 第一个this&#125;new Foo(); 我们new了一个Foo对象，那么this.method中的this指向的是new的对象，否则无法调用method方法。但是进了method方法后，方法中的this又指向了window，因此this.value的值为undefined。 我们在外层添加一段代码，再看看，代码2.2： 123456789101112var value=33; function Foo() &#123; this.value = 42; this.method = function() &#123; // this 指向全局对象 alert(this) // 输出window 第二个this alert(this.value); // 输出：33 第二个this &#125;; setTimeout(this.method, 500); // 这里的this指向Foo的实例对象 第一个this&#125;new Foo(); 从这里，可以明显的看到，method方法中的this指向的是window，因为可以输出外层的value值。那为什么setTimeout中的this指向的是Foo的实例对象呢？ 我觉得代码2.2就等价于下面的代码，如代码2.3： 1234567var value=33; function Foo() &#123; this.value = 42; setTimeout(function()&#123;alert(this);alert(this.value)&#125;, 500); // 先后输出 window 33 这里是第二个this&#125;new Foo(); setTimeout中的第一个参数就是一个单纯的函数的引用而已，而函数中的this仍然指向的是window。在setTimeout(this.method, time) 中的this是可以根据上下文而改变的，其最终的目的是要得到一个函数指针。我们再来验证一下，看代码2.4: 12345678910function method() &#123; alert(this.value); // 输出 42 第二个this&#125; function Foo() &#123; this.value = 42; setTimeout(this.method, 500); // 这里this指向window 第一个this&#125; Foo(); 这次我们将Foo当成方法直接执行，method方法放到外层，即挂在window上面。而this则指向了window，因此可以调用method方法。method方法中的this仍然指向window，而Foo()执行的时候，对window.value进行了赋值(this.value=42)，因此输出了42。 三、实践。知道了得出的结论，我们来阅读一下比较奇葩的一些代码，进行验证。 首先在一个函数中，调用setTimeout。代码3.1： 12345678910var test = "in the window"; setTimeout(function() &#123;alert('outer ' + test)&#125;, 0); // 输出 outer in the window ，默认在window的全局作用域下 function f() &#123; var test = 'in the f!'; // 局部变量，window作用域不可访问 setTimeout('alert("inner " + test)', 0); // 输出 outer in the window, 虽然在f方法的中调用，但执行代码(字符串形式的代码)默认在window全局作用域下，test也指向全局的test&#125; f(); 在f方法中，setTimeout中的test的值是外层的test，而不是f作用域中的test。再看代码3.2： 12345678910var test = "in the window"; setTimeout(function() &#123;alert('outer' + test)&#125;, 0); // outer in the window ，没有问题，在全局下调用，访问全局中的test function f() &#123; var test = 'in the f!'; setTimeout(function()&#123;alert('inner '+ test)&#125;, 0); // inner in the f! 有问题，不是说好了执行函数中的this指向的是window吗？那test也应该对应window下的值才对，怎么test的值却是 f()中的值呢？？？？&#125; f(); 按照前面的经验，f中的setTimeout中的test也应该明明应该是指向外层的test才对吧？？？我们注意到，这个f里面的setTimeout中的第一个参数是一个匿名函数，这是上面两端代码最大的不同。而只要是函数就有它的作用域，我们可以将上面的代码替换成下面的代码3.3： 12345678910111213var test = "in the window"; setTimeout(function() &#123;alert('outer ' + test)&#125;, 0); // in the window function f() &#123; var test = 'in the f!'; function ff() &#123;alert('inner ' + test)&#125; // 能访问到f中的test局部变量 setTimeout(ff, 0); // inner in the f!&#125; f(); 再看一段更清晰的代码，3.4： 1234567var value=33; function Foo() &#123; var value = 42; setTimeout(function()&#123;alert(value);alert(this.value)&#125;, 500); // 先后输出 42 然后输出33 这里的this是第二个this&#125;new Foo(); 可以确定，延迟执行函数中的this的确是指向了window，毫无疑问，上面的所有代码都可以验证哈。但是延迟执行函数中的其他变量需要根据上下文来确认。 修改代码3.4为3.5，去掉匿名函数的调用方式，会更加清晰： 1234567891011var value=33; function Foo() &#123; var value = 42; function ff() &#123; alert(value); // 42 alert(this.value); // 33 &#125; setTimeout(ff, 500); // 先后输出 42 33 &#125;Foo(); // 直接执行，跟普通函数没有区别 因此，如果去掉Foo中的value=42的话，那么value的值等于多少呢？undefined还是外层的33？？请看3.5： 12345678910var value=33; function Foo() &#123; function ff() &#123; alert(value); // 输出33 alert(this.value); // 输出33 this指向window &#125; setTimeout(ff, 500); // 先后输出 33 33&#125;Foo(); 没错，就是外层的33，因为ff可以访问到window下的value值，就如同setTimeout中的匿名函数一样。 最后，我们通过对象的方式进行调用，代码3.6： 12345678910111213var obj = &#123; name: 'hutaoer', say: function() &#123; var self = this; setTimeout(function()&#123; alert(self); // 输出 object ，指向obj alert(this); // 第二个this，指向window，我心永恒，从未改变 alert(self.name) // 输出 hutaoer &#125;, 0) &#125;&#125; obj.say(); 最后，如果您到看懂了上面的例子，那么我们可以回顾一下得出的一些结论咯： 一、setTimeout中的延迟执行代码中的this永远都指向window 二、setTimeout(this.method, time)这种形式中的this，即上文中提到的第一个this，是根据上下文来判断的，默认为全局作用域，但不一定总是处于全局下，具体问题具体分析。 三、setTimeout(匿名函数, time)这种形式下，匿名函数中的变量也需要根据上下文来判断，具体问题具体分析。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅拷贝与深拷贝]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[JS 中有一些基本类型像是Number、String、Boolean，而对象就是像这样的东西{ name: ‘Larry’, skill: ‘Node.js’ }，对象跟基本类型最大的不同就在于他们的传值方式。 基本类型是按值传递，像是这样：在修改a时并不会改到b 12345var a = 25;var b = a;b = 18;console.log(a);//25console.log(b);//18 但对象就不同，对象传的是按引用传值： 12345var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;var obj2 = obj1;obj2.b = 100;console.log(obj1);// &#123; a: 10, b: 100, c: 30 &#125;, b 被改到了console.log(obj2);// &#123; a: 10, b: 100, c: 30 &#125; 复制一份obj1叫做obj2，然后把obj2.b改成100，但却不小心改到obj1.b，因为他们根本是同一个对象，这就是所谓的浅拷贝。 要避免这样的错误发生就要写成这样： 12345var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;var obj2 = &#123; a: obj1.a, b: obj1.b, c: obj1.c &#125;;obj2.b = 100;console.log(obj1);// &#123; a: 10, b: 20, c: 30 &#125;, b 沒被改到console.log(obj2);// &#123; a: 10, b: 100, c: 30 &#125; 这样就是深拷贝，不会改到原本的obj1。 浅拷贝(Shallow Copy) VS 深拷贝(Deep Copy) 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 浅拷贝的实现方式也就是简单地复制而已 1、简单地复制语句 1234567891011121314151617181920212223242526function simpleClone(initalObj) &#123; var obj = &#123;&#125;; for (var i in initalObj) &#123; obj[i] = initalObj[i]; &#125; return obj; &#125; var obj = &#123; a: "hello", b: &#123;a: "world", b: 21&#125;, c: ["Bob", "Tom", "Jenny"], d: function () &#123; alert("hello world"); &#125; &#125; var cloneObj = simpleClone(obj); console.log(cloneObj.b); console.log(cloneObj.c); console.log(cloneObj.d); cloneObj.b.a = "changed"; cloneObj.c = [1, 2, 3]; cloneObj.d = function () &#123; alert("changed"); &#125;; console.log(obj.b); console.log(obj.c); console.log(obj.d); 结果为： 2、Object.assign() Object.assign是ES6的新函数。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 1Object.assign(target, ...sources) 参数： target：目标对象。sources：任意多个源对象。返回值：目标对象会被返回。 1234var obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;;var initalObj = Object.assign(&#123;&#125;, obj);initalObj.a.a = "changed";console.log(obj.a.a); // "changed" 兼容性： 需要注意的是： Object.assign()可以处理一层的深度拷贝，如下： 12345var obj1 = &#123;a: 10, b: 20, c: 30&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj2.b = 100;console.log(obj1);// &#123; a: 10, b: 20, c: 30 &#125; , 沒被改到console.log(obj2); // &#123; a: 10, b: 100, c: 30 &#125; 深拷贝的实现方式要完全复制又不能修改到原对象，这时候就要用 Deep Copy，这里会介绍几种Deep Copy 的方式。 1、手动复制 把一个对象的属性复制给另一个对象的属性 12345var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;var obj2 = &#123; a: obj1.a, b: obj1.b, c: obj1.c &#125;;obj2.b = 100;console.log(obj1);// &#123; a: 10, b: 20, c: 30 &#125;, 沒被改到console.log(obj2);// &#123; a: 10, b: 100, c: 30 &#125; 但这样很麻烦，要一个一个自己复制；而且这样的本质也不能算是 Deep Copy，因为对象里面也可能回事对象，如像下面这个状况： 1234567var obj1 = &#123; body: &#123; a: 10 &#125; &#125;;var obj2 = &#123; body: obj1.body &#125;;obj2.body.a = 20;console.log(obj1);// &#123; body: &#123; a: 20 &#125; &#125;,被改到了console.log(obj2);// &#123; body: &#123; a: 20 &#125; &#125;console.log(obj1 === obj2); // falseconsole.log(obj1.body === obj2.body); // true 虽然obj1跟obj2是不同对象，但他们会共享同一个obj1.body，所以修改obj2.body.a时也会修改到旧的。 2、对象只有一层的话可以使用上面的：Object.assign()函数 1Object.assign(&#123;&#125;, obj1)`的意思是先建立一个空对象&#123;&#125;，接着把`obj1`中所有的属性复制过去，所以`obj2`会长得跟`obj1`一样，这时候再修改`obj2.b`也不会影响`obj1。 因为Object.assign跟我们手动复制的效果相同，所以一样只能处理深度只有一层的对象，没办法做到真正的 Deep Copy。不过如果要复制的对象只有一层的话可以考虑使用它。 3、转成 JSON 再转回来 用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。 12345678var obj1 = &#123; body: &#123; a: 10 &#125; &#125;;var obj2 = JSON.parse(JSON.stringify(obj1));obj2.body.a = 20;;console.log(obj1);// &#123; body: &#123; a: 10 &#125; &#125; //沒被改到console.log(obj2);// &#123; body: &#123; a: 20 &#125; &#125;console.log(obj1 === obj2);// falseconsole.log(obj1.body === obj2.body);// false //这样做是真正的Deep Copy，这种方法简单易用。 但是这种方法也有不少坏处，譬如它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。 这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp对象是无法通过这种方式深拷贝。 也就是说，只有可以转成JSON格式的对象才可以这样用，像function没办法转成JSON。 1234var obj1 = &#123; fun: function()&#123; console.log(123) &#125; &#125;;var obj2 = JSON.parse(JSON.stringify(obj1));console.log(typeof obj1.fun);// 'function'console.log(typeof obj2.fun);// 'undefined', 没复制 要复制的function会直接消失，所以这个方法只能用在单纯只有数据的对象。 4、递归拷贝 1234567891011121314151617function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; if (typeof initalObj[i] === 'object') &#123; obj[i] = (initalObj[i].constructor === Array) ? [] : &#123;&#125;; arguments.callee(initalObj[i], obj[i]); &#125; else &#123; obj[i] = initalObj[i]; &#125; &#125; return obj; &#125; var str = &#123;&#125;; var obj = &#123;a: &#123;a: "hello", b: 21&#125;&#125;; deepClone(obj, str); console.log(str.a); 上述代码确实可以实现深拷贝。但是当遇到两个互相引用的对象，会出现死循环的情况。 为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否相互引用对象，如果是则退出循环。 改进版代码如下： 1234567891011121314151617181920function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if (prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : &#123;&#125;; arguments.callee(prop, obj[i]); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj; &#125; var str = &#123;&#125;; var obj = &#123;a: &#123;a: "hello", b: 21&#125;&#125;; deepClone(obj, str); console.log(str.a); 5、使用Object.create()方法 直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。 12345678910111213141516function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if (prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] :Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj; &#125; 6、jquery jquery 有提供一个$.extend可以用来做 Deep Copy。 1234var $ = require('jquery');var obj1 = &#123;a: 1, b: &#123;f: &#123;g: 1&#125;&#125;, c: [1, 2, 3]&#125;;var obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f);// false 7、lodash 另外一个很热门的函数库lodash，也有提供_.cloneDeep用来做 Deep Copy。 1234var _ = require('lodash'); var obj1 = &#123;a: 1, b: &#123;f: &#123;g: 1&#125;&#125;, c: [1, 2, 3]&#125;; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f);// false 这个性能还不错，使用起来也很简单。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>浅拷贝与深拷贝</tag>
      </tags>
  </entry>
</search>
