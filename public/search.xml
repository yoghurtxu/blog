<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图解HTTP缓存]]></title>
    <url>%2F2020%2F01%2F12%2F%E5%9B%BE%E8%A7%A3HTTP%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[前言HTTP 的缓存机制，可以说这是前端工程师需要掌握的重要知识点之一。本文将针对 HTTP 缓存整体的流程做一个详细的讲解，争取做到大家读完整篇文章后，对缓存有一个整体的了解。 HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。主要作用是可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力。这是缓存运作的一个整体流程图： 强缓存不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。 ○ ExpiresExpires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。 ○ Cache-ControlCache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有： max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效 no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜 no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源 private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应 public：响应可以被中间代理、CDN 等缓存 must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证 ○ PragmaPragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。 本地通过 express 起一个服务来验证强缓存的 3 个属性，代码如下： 123456789101112const express = require(&apos;express&apos;);const app = express();var options = &#123; etag: false, // 禁用协商缓存 lastModified: false, // 禁用协商缓存 setHeaders: (res, path, stat) =&gt; &#123; res.set(&apos;Cache-Control&apos;, &apos;max-age=10&apos;); // 强缓存超时时间为10秒 &#125;,&#125;;app.use(express.static((__dirname + &apos;/public&apos;), options));app.listen(3000);复制代码 第一次加载，页面会向服务器请求数据，并在 Response Header 中添加 Cache-Control ，过期时间为 10 秒。 第二次加载，Date 头属性未更新，可以看到浏览器直接使用了强缓存，实际没有发送请求。 过了 10 秒的超时时间之后，再次请求资源： 当 Pragma 和 Cache-Control 同时存在的时候，Pragma 的优先级高于 Cache-Control。 协商缓存当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。 ○ ETag/If-None-MatchETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。 ○ Last-Modified/If-Modified-SinceLast-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。 本地通过 express 起一个服务来验证协商缓存，代码如下： 123456789101112131415const express = require(&apos;express&apos;);const app = express();var options = &#123; etag: true, // 开启协商缓存 lastModified: true, // 开启协商缓存 setHeaders: (res, path, stat) =&gt; &#123; res.set(&#123; &apos;Cache-Control&apos;: &apos;max-age=00&apos;, // 浏览器不走强缓存 &apos;Pragma&apos;: &apos;no-cache&apos;, // 浏览器不走强缓存 &#125;); &#125;,&#125;;app.use(express.static((__dirname + &apos;/public&apos;), options));app.listen(3001);复制代码 第一次请求资源: 第二次请求资源，服务端根据请求头中的 If-Modified-Since 和 If-None-Match 验证文件是否修改。 我们再来验证一下 ETag 在强校验的情况下，只增加一行空格，hash 值如何变化，在代码中，我采用的是对文件进行 MD5 加密来计算其 hash 值。 注：只是为了演示用，实际计算不是通过 MD5 加密的，Apache 默认通过 FileEtag 中 FileEtag INode Mtime Size 的配置自动生成 ETag，用户可以通过自定义的方式来修改文件生成 ETag 的方式。 为了保证 lastModified 不影响缓存，我把通过 Last-Modified/If-Modified-Since 请求头删除了，源码如下： 1234567891011121314151617181920const express = require(&apos;express&apos;);const CryptoJS = require(&apos;crypto-js/crypto-js&apos;);const fs = require(&apos;fs&apos;);const app = express();var options = &#123; etag: true, // 只通过Etag来判断 lastModified: false, // 关闭另一种协商缓存 setHeaders: (res, path, stat) =&gt; &#123; const data = fs.readFileSync(path, &apos;utf-8&apos;); // 读取文件 const hash = CryptoJS.MD5((JSON.stringify(data))); // MD5加密 res.set(&#123; &apos;Cache-Control&apos;: &apos;max-age=00&apos;, // 浏览器不走强缓存 &apos;Pragma&apos;: &apos;no-cache&apos;, // 浏览器不走强缓存 &apos;ETag&apos;: hash, // 手动设置Etag值为MD5加密后的hash值 &#125;); &#125;,&#125;;app.use(express.static((__dirname + &apos;/public&apos;), options));app.listen(4000); // 使用新端口号，否则上面验证的协商缓存会一直存在复制代码 第一次和第二次请求如下： 然后我修改了 test.js ，增加一个空格后再删除一个空格，保持文件内容不变，但文件的修改时间改变，发起第三次请求，由于我生成 ETag 的方式是通过对文件内容进行 MD5 加密生成，所以虽然修改时间变化了，但请求依然返回了 304 ，读取浏览器缓存。 ETag/If-None-Match 的出现主要解决了 Last-Modified/If-Modified-Since 所解决不了的问题： 如果文件的修改频率在秒级以下，Last-Modified/If-Modified-Since 会错误地返回 304 如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304 ，上面的例子就说明了这个问题 总结在实际使用场景中，比如政采云的官网。图片、不常变化的 JS 等静态资源都会使用缓存来提高页面的加载速度。例如政采云首页的顶部导航栏，埋点 SDK 等等。 在文章的最后，我们再次回到这张流程图，这张图涵盖了 HTTP 缓存的整体流程，大家对整体流程熟悉后，也可以自己动手通过 Node 来验证下 HTTP 缓存。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮点数陷阱及解法]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E9%98%B1%E5%8F%8A%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[众所周知，JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体就说不清楚了。本文帮你理清这背后的原理以及解决方案，还会向你解释JS中的大数危机和四则运算中会遇到的坑。 浮点数的存储首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。计算机组成原理中有过详细介绍，如果你不记得也没关系。 这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。 64位比特又可分为三个部分： 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数 指数位E：中间的 11 位存储指数（exponent），用来表示次方数 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零 ￼ 实际数字就可以用以下公式来计算：￼$ V = (-1)^{S}\times M \times 2^{E} $ 注意以上的公式遵循科学计数法的规范，在十进制是为0&lt;M&lt;10，到二进行就是0&lt;M&lt;2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如 4.5 转换成二进制就是 100.1，科学计数法表示是 1.001*2^2，舍去1后 M = 001。E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以再减去一个中间数 1023，[0,1022]表示为负，[1024,2047] 表示为正。如4.5 的指数E = 1025，尾数M为 001。 最终的公式变成： $ V = (-1)^{S}\times (M+1) \times 2^{E-1023} $ 所以 4.5 最终表示为（M=001、E=1025）：￼ (图片由此生成 www.binaryconvert.com/convert_dou…) 下面再以 0.1 例解释浮点误差的原因， 0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011...。最终就是： ￼转化成十进制后为 0.100000000000000005551115123126，因此就出现了浮点误差。 为什么 0.1+0.2=0.30000000000000004？计算步骤为： 123456// 0.1 和 0.2 都转化成二进制后再进行运算0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 为什么 x=0.1 能得到 0.1？恭喜你到了看山不是山的境界。因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度。它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有： 123450.10000000000000000555.toPrecision(16)// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1// 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试：0.1.toPrecision(21) = 0.100000000000000005551 大数危机可能你已经隐约感觉到了，如果整数大于 9007199254740992 会出现什么情况呢？由于 E 最大值是 1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity 12345&gt; Math.pow(2, 1023)8.98846567431158e+307&gt; Math.pow(2, 1024)Infinity 那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？ (2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数 (2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数 … 依次跳过更多2的倍数 下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系。我们常用的 (-2^53, 2^53) 只是最中间非常小的一部分，越往两边越稀疏越不精确。 在淘宝早期的订单系统中把订单号当作数字处理，后来随意订单号暴增，已经超过了9007199254740992，最终的解法是把订单号改成字符串处理。 要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多。所以原生支持大数就很有必要了，现在 TC39 已经有一个 Stage 3 的提案 proposal bigint，大数问题有问彻底解决。 toPrecision vs toFixed数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。 不同点就需要注意一下： toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。 toFixed 是小数点后指定位数取整，从小数点开始数起。 两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。 如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。 原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！ 解法：使用专业的四舍五入函数 Math.round() 来处理。但 Math.round(1.005 * 100) / 100 还是不行，因为 1.005 * 100 = 100.49999999999999。还需要把乘法和除法精度误差都解决后再使用 Math.round。可以使用后面介绍的 number-precision#round 方法来解决。 解决方案回到最关心的问题：如何解决浮点误差。首先，理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。 数据展示类当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下： 1parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True 封装成方法就是： 123function strip(num, precision = 12) &#123; return +parseFloat(num.toPrecision(precision));&#125; 为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。 数据运算类对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例： 123456789/** * 精确加法 */function add(num1, num2) &#123; const num1Digits = (num1.toString().split(&apos;.&apos;)[1] || &apos;&apos;).length; const num2Digits = (num2.toString().split(&apos;.&apos;)[1] || &apos;&apos;).length; const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits)); return (num1 * baseNum + num2 * baseNum) / baseNum;&#125; 以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。 能读到这里，说明你非常有耐心，那我就放个福利吧。遇到浮点数误差问题时可以直接使用github.com/dt-fe/numbe… 完美支持浮点数的加减乘除、四舍五入等运算。非常小只有1K，远小于绝大多数同类库（如Math.js、BigDecimal.js），100%测试全覆盖，代码可读性强，不妨在你的应用里用起来！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数值计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios 是如何封装 HTTP 请求的]]></title>
    <url>%2F2019%2F10%2F16%2Faxios%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%20HTTP%20%E8%AF%B7%E6%B1%82%E7%9A%84%2F</url>
    <content type="text"><![CDATA[概述前端开发中，经常会遇到发送异步请求的场景。一个功能齐全的 HTTP 请求库可以大大降低我们的开发成本，提高开发效率。axios 就是这样一个 HTTP 请求库，近年来非常热门。目前，它在 GitHub 上拥有超过 40,000 的 Star，许多权威人士都推荐使用它。因此，我们有必要了解下 axios 是如何设计，以及如何实现 HTTP 请求库封装的。撰写本文时，axios 当前版本为 0.18.0，我们以该版本为例，来阅读和分析部分核心源代码。axios 的所有源文件都位于 lib 文件夹中，下文中提到的路径都是相对于 lib 来说的。 本文我们主要讨论：怎样使用 axios。 axios 的核心模块（请求、拦截器、撤销）是如何设计和实现的？ axios 的设计优点是什么？ 如何使用 axios要理解 axios 的设计，首先需要看一下如何使用 axios。我们举一个简单的例子来说明下 axios API 的使用。 发送请求12345678axios(&#123; method:&apos;get&apos;, url:&apos;http://bit.ly/2mTM3nY&apos;, responseType:&apos;stream&apos;&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream(&apos;ada_lovelace.jpg&apos;))&#125;); 这是一个官方示例。从上面的代码中可以看到，axios 的用法与 jQuery 的 ajax 方法非常类似，两者都返回一个 Promise 对象（在这里也可以使用成功回调函数，但还是更推荐使用 Promise 或 await），然后再进行后续操作。这个实例很简单，不需要我解释了。我们再来看看如何添加一个拦截器函数。 添加拦截器函数1234567891011121314151617// 添加一个请求拦截器。注意，这里面有 2 个函数——分别是成功和失败时的回调函数，这样设计的原因会在之后介绍axios.interceptors.request.use(function (config) &#123; // 发起请求前执行一些处理任务 return config; // 返回配置信息 &#125;, function (error) &#123; // 请求错误时的处理 return Promise.reject(error); &#125;);// 添加一个响应拦截器axios.interceptors.response.use(function (response) &#123; // 处理响应数据 return response; // 返回响应数据 &#125;, function (error) &#123; // 响应出错后所做的处理工作 return Promise.reject(error); &#125;); 从上面的代码，我们可以知道：发送请求之前，我们可以对请求的配置参数（config）做处理；在请求得到响应之后，我们可以对返回数据做处理。当请求或响应失败时，我们还能指定对应的错误处理函数。 撤销 HTTP 请求在开发与搜索相关的模块时，我们经常要频繁地发送数据查询请求。一般来说，当我们发送下一个请求时，需要撤销上个请求。因此，能撤销相关请求功能非常有用。axios 撤销请求的示例代码如下： 1234567891011121314151617181920212223const CancelToken = axios.CancelToken;const source = CancelToken.source();// 例子一axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;请求撤销了&apos;, thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);// 例子二axios.post(&apos;/user/12345&apos;, &#123; name: &apos;新名字&apos;&#125;, &#123; cancelToken: source.token&#125;).// 撤销请求 (信息参数是可选的)source.cancel(&apos;用户撤销了请求&apos;); 从上例中可以看到，在 axios 中，使用基于 CancelToken 的撤销请求方案。然而，该提案现已撤回，详情如 点这里。具体的撤销请求的实现方法，将在后面的源代码分析的中解释。 axios 核心模块的设计和实现通过上面的例子，我相信每个人都对 axios 的使用有一个大致的了解了。下面，我们将根据模块分析 axios 的设计和实现。下面的图片，是我在本文中会介绍到的源代码文件。如果您感兴趣，最好在阅读时克隆相关的代码，这能加深你对相关模块的理解。 请求模块的代码放在了 core/dispatchRequest.js 文件中，这里我只展示了一些关键代码来简单说明： 12345678910111213141516171819202122232425module.exports = function dispatchRequest(config) &#123; throwIfCancellationRequested(config); // 其他源码 // 默认适配器是一个模块，可以根据当前环境选择使用 Node 或者 XHR 发送请求。 var adapter = config.adapter || defaults.adapter; return adapter(config).then(function onAdapterResolution(response) &#123; throwIfCancellationRequested(config); // 其他源码 return response; &#125;, function onAdapterRejection(reason) &#123; if (!isCancel(reason)) &#123; throwIfCancellationRequested(config); // 其他源码 return Promise.reject(reason); &#125;);&#125;; 上面的代码中，我们能够知道 dispatchRequest 方法是通过 config.adapter ，获得发送请求模块的。我们还可以通过传递，符合规范的适配器函数来替代原来的模块（一般来说，我们不会这样做，但它是一个松散耦合的扩展点）。在 defaults.js 文件中，我们可以看到相关适配器的选择逻辑——根据当前容器的一些独特属性和构造函数，来确定使用哪个适配器。 123456789101112function getDefaultAdapter() &#123; var adapter; // 只有在 Node.js 中包含 process 类型对象时，才使用它的请求模块 if (typeof process !== &apos;undefined&apos; &amp;&amp; Object.prototype.toString.call(process) === &apos;[object process]&apos;) &#123; // Node.js 请求模块 adapter = require(&apos;./adapters/http&apos;); &#125; else if (typeof XMLHttpRequest !== &apos;undefined&apos;) &#123; // 浏览器请求模块 adapter = require(&apos;./adapters/xhr&apos;); &#125; return adapter;&#125; axios 中的 XHR 模块相对简单，它是对 XMLHTTPRequest 对象的封装，这里我就不再解释了。有兴趣的同学，可以自己阅读源源码看看，源码位于 adapters/xhr.js 文件中。 拦截器模块现在让我们看看 axios 是如何处理，请求和响应拦截器函数的。这就涉及到了 axios 中的统一接口 ——request 函数。 12345678910111213141516171819202122Axios.prototype.request = function request(config) &#123;// 其他源码var chain = [dispatchRequest, undefined];var promise = Promise.resolve(config);this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123; chain.unshift(interceptor.fulfilled, interceptor.rejected);&#125;);this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123; chain.push(interceptor.fulfilled, interceptor.rejected);&#125;);while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift());&#125;return promise;&#125;; 这个函数是 axios 发送请求的接口。因为函数实现代码相当长，这里我会简单地讨论相关设计思想： chain 是一个执行队列。队列的初始值是一个携带配置（config）参数的 Promise 对象。 在执行队列中，初始函数 dispatchRequest 用来发送请求，为了与 dispatchRequest对应，我们添加了一个 undefined。添加 undefined 的原因是需要给 Promise 提供成功和失败的回调函数，从下面代码里的 promise = promise.then(chain.shift(), chain.shift()); 我们就能看出来。因此，函数 dispatchRequest 和 undefiend 可以看成是一对函数。 在执行队列 chain 中，发送请求的 dispatchReqeust 函数处于中间位置。它前面是请求拦截器，使用 unshift 方法插入；它后面是响应拦截器，使用 push 方法插入，在 dispatchRequest 之后。需要注意的是，这些函数都是成对的，也就是一次会插入两个。 浏览上面的 request 函数代码，我们大致知道了怎样使用拦截器。下一步，来看看怎样撤销一个 HTTP 请求。 撤销请求模块与撤销请求相关的模块位于 Cancel/ 文件夹下，现在我们来看下相关核心代码。首先，我们来看下基础 Cancel 类。它是一个用来记录撤销状态的类，具体代码如下： 123456789function Cancel(message) &#123; this.message = message;&#125;Cancel.prototype.toString = function toString() &#123; return &apos;Cancel&apos; + (this.message ? &apos;: &apos; + this.message : &apos;&apos;);&#125;;Cancel.prototype.__CANCEL__ = true; 使用 CancelToken 类时，需要向它传递一个 Promise 方法，用来实现 HTTP 请求的撤销，具体代码如下： 123456789101112131415161718192021222324252627282930313233function CancelToken(executor) &#123; if (typeof executor !== &apos;function&apos;) &#123; throw new TypeError(&apos;executor must be a function.&apos;); &#125;var resolvePromise;this.promise = new Promise(function promiseExecutor(resolve) &#123; resolvePromise = resolve;&#125;);var token = this;executor(function cancel(message) &#123; if (token.reason) &#123; // 已经被撤销了 return; &#125; token.reason = new Cancel(message); resolvePromise(token.reason);&#125;);&#125;CancelToken.source = function source() &#123; var cancel; var token = new CancelToken(function executor(c) &#123; cancel = c; &#125;); return &#123; token: token, cancel: cancel &#125;;&#125;; adapters/xhr.js 文件中，撤销请求的地方是这样写的： 1234567891011121314if (config.cancelToken) &#123; // 等待撤销 config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (!request) &#123; return; &#125; request.abort(); reject(cancel); // 重置请求 request = null;&#125;);&#125; 通过上面的撤销 HTTP请求的例子，让我们简要地讨论一下相关的实现逻辑： 在需要撤销的请求中，调用 CancelToken 类的 source 方法类进行初始化，会得到一个包含 CancelToken 类实例 A 和 cancel 方法的对象。 当 source 方法正在返回实例 A 的时候，一个处于 pending 状态的 promise 对象初始化完成。在将实例 A 传递给 axios 之后，promise 就可以作为撤销请求的触发器使用了。 当调用通过 source 方法返回的 cancel 方法后，实例 A 中 promise 状态从 pending 变成 fulfilled，然后立即触发 then 回调函数。于是 axios 的撤销方法——request.abort() 被触发了。 axios 这样设计的好处是什么？发送请求函数的处理逻辑如前几章所述，axios 不将用来发送请求的 dispatchRequest 函数看做一个特殊函数。实际上，dispatchRequest 会被放在队列的中间位置，以便保证队列处理的一致性和代码的可读性。 适配器的处理逻辑在适配器的处理逻辑上，http 和 xhr 模块（一个是在 Node.js 中用来发送请求的，一个是在浏览器里用来发送请求的）并没有在 dispatchRequest 函数中使用，而是各自作为单独的模块，默认通过 defaults.js 文件中的配置方法引入的。因此，它不仅确保了两个模块之间的低耦合，而且还为将来的用户提供了定制请求发送模块的空间。 撤销 HTTP 请求的逻辑在撤销 HTTP 请求的逻辑中，axios 设计使用 Promise 来作为触发器，将 resolve 函数暴露在外面，并在回调函数里使用。它不仅确保了内部逻辑的一致性，而且还确保了在需要撤销请求时，不需要直接更改相关类的样例数据，以避免在很大程度上入侵其他模块。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中with的用法]]></title>
    <url>%2F2019%2F09%2F17%2Fwith%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[说起js中的with关键字，很多小伙伴们的第一印象可能就是with关键字的作用在于改变作用域，然后最关键的一点是不推荐使用with关键字。听到不推荐with关键字后，我们很多人都会忽略掉with关键字，认为不要去管它用它就可以了。但是有时候，我们在看一些代码或者面试题的时候，其中会有with关键字的相关问题，很多坑是你没接触过的，所以还是有必要说说with这一个关键字。 with的基本用法with 语句的原本用意是为逐级的对象访问提供命名空间式的速写方式. 也就是在指定的代码区域, 直接通过节点名称调用对象。 with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 比如，目前现在有一个这样的对象： 12345var obj = &#123; a: 1, b: 2, c: 3&#125;; 如果想要改变 obj 中每一项的值，一般写法可能会是这样： 1234// 重复写了3次的“obj”obj.a = 2;obj.b = 3;obj.c = 4; 而用了 with 的写法，会有一个简单的快捷方式 12345with (obj) &#123; a = 3; b = 4; c = 5;&#125; 在这段代码中，使用了 with 语句关联了 obj 对象，这就以为着在 with 代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性。 with的弊端在上面的例子中，我们可以看到，with 可以很好地帮助我们简化代码。但是为什么不推荐使用呢？下面我们来说说with的缺点： 导致数据泄漏我们来看下面的这部分代码 1234567891011121314151617181920function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;foo(o1);console.log(o1.a); //2foo(o2);console.log(o2.a); //underfinedconsole.log(a); //2，a被泄漏到全局作用域上 首先，我们来分析上面的代码。例子中创建了 o1 和 o2 两个对象。其中一个有 a 属性，另外一个没有。foo(obj) 函数接受一个 obj 的形参，该参数是一个对象引用，并对该对象引用执行了 with(obj) {…}。在 with 块内部，对 a 有一个词法引用，实际上是一个 LHS引用，将 2 赋值给了它。 当我们将 o1 传递进去，a = 2 赋值操作找到了 o1.a 并将 2 赋值给它。而当 o2 传递进去，o2 并没有 a 的属性，因此不会创建这个属性，o2.a 保持 undefined。 但为什么对 o2的操作会导致数据的泄漏呢？ 这里需要回到对 LHS查询 的机制问题（详情可移步 JavaScript中的LHS和RHS查询）。 当我们传递 o2 给 with 时，with 所声明的作用域是 o2, 从这个作用域开始对 a 进行 LHS查询。o2 的作用域、foo(…) 的作用域和全局作用域中都没有找到标识符 a，因此在非严格模式下，会自动在全局作用域创建一个全局变量），在严格模式下，会抛出ReferenceError 异常。 另一个不推荐 with 的原因是。在严格模式下，with 被完全禁止，间接或非安全地使用 eval(…) 也被禁止了。 性能下降with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。with 可以使代码更具有扩展性，虽然有着上面的数据泄漏的可能，但只要稍加注意就可以避免，难道不是可以创造出很好地功能吗？ 答案是否定的，具体原因我们先来看下面的这部分代码。 1234567891011121314151617181920212223242526272829function func() &#123; console.time(&quot;func&quot;); var obj = &#123; a: [1, 2, 3] &#125;; for(var i = 0; i &lt; 100000; i++) &#123; var v = obj.a[0]; &#125; console.timeEnd(&quot;func&quot;);&#125;func();function funcWith() &#123; console.time(&quot;funcWith&quot;); var obj = &#123; a: [1, 2, 3] &#125;; with(obj) &#123; for(var i = 0; i &lt; 100000; i++) &#123; var v = a[0]; &#125; &#125; console.timeEnd(&quot;funcWith&quot;);&#125;funcWith(); 在处理相同逻辑的代码中，没用 with 的运行时间仅为 4.63 ms。而用 with 的运用时间长达 81.87ms。 这是为什么呢？ 原因是 JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 但如果引擎在代码中发现了 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了 with ，所有的优化都可能是无意义的。因此引擎会采取最简单的做法就是完全不做任何优化。如果代码大量使用 with 或者 eval()，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢的事实。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>with</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue数据劫持]]></title>
    <url>%2F2019%2F09%2F16%2Fvue%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[vue3.0怎么实现数据劫持的什么是数据劫持数据劫持通常我们利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。 数据劫持的优势 不用复杂的调用 可以得知变化的数据 首先我们看下2.x用Object.defineProperty实现的简单的双向绑定 123456789101112131415const obj = &#123;&#125;;Object.defineProperty(obj, 'text', &#123; get: function() &#123; console.log('get val'); &#125;, set: function(newVal) &#123; console.log('set val:'+newVal) document.getElementById('input').value = newVal; document.getElementById('span').innerHTML = newVal; &#125;&#125;);const oinput = document.getElementById('input');oinput.addEventListener('keyup', function(e)&#123; obj.text = e.target.value; &#125;) Vue2.x的缺陷属性值改为数组就无法监听数组变化 尤大神用了一些奇技淫巧,把无法监听数组的情况hack掉了 123456789101112131415161718192021const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];const arrayAugmentations = [];aryMethods.forEach((method)=&gt; &#123; // 这里是原生Array的原型方法 let original = Array.prototype[method]; // 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上 // 注意：是属性而非原型属性 arrayAugmentations[method] = function () &#123; console.log('我被改变啦!'); // 调用对应的原生方法并返回结果 return original.apply(this, arguments); &#125;;&#125;);let list = ['a', 'b', 'c'];// 将我们要监听的数组的原型指针指向上面定义的空数组对象// 别忘了这个空数组的属性上定义了我们封装好的push等方法list.__proto__ = arrayAugmentations;list.push('d'); // 我被改变啦！ 4// 这里的list2没有被重新定义原型指针，所以就正常输出let list2 = ['a', 'b', 'c'];list2.push('d'); // 4 只能劫持对象的属性假如需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 Vue3.x的特点带着以上缺点我们看下3.x版本怎么实现数据劫持 3.x版本中把Object.defineProperty换成Proxy Proxy在ES6规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy是Object.defineProperty的全方位加强版 如果对Proxy属性还不是很了解的小伙伴 可以翻阅下Es6官方文档 Proxy可以直接监听数组的变化123456789101112131415161718192021222324252627282930313233343536373839404142434445const olist = document.getElementById('list');const obtn = document.getElementById('btn');// 渲染列表const Render = &#123; // 初始化 init: function(arr) &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) &#123; const li = document.createElement('li'); li.textContent = arr[i]; fragment.appendChild(li); &#125; olist.appendChild(fragment); &#125;, // 我们只考虑了增加的情况,仅作为示例 change: function(val) &#123; const li = document.createElement('li'); li.textContent = val; olist.appendChild(li); &#125;,&#125;;// 初始数组const arr = [1, 2, 3, 4];// 监听数组const newArr = new Proxy(arr, &#123; get: function(target, key, receiver) &#123; console.log(key); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key !== 'length') &#123; Render.change(value); &#125; return Reflect.set(target, key, value, receiver); &#125;,&#125;);// 初始化window.onload = function() &#123; Render.init(arr);&#125;// push数字obtn.addEventListener('click', function() &#123; newArr.push(6);&#125;); Proxy可以直接监听对象而非属性1234567891011121314151617181920const input = document.getElementById('input');const p = document.getElementById('p');const obj = &#123;&#125;;const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key === 'text') &#123; input.value = value; p.innerHTML = value; &#125; return Reflect.set(target, key, value, receiver); &#125;,&#125;);input.addEventListener('keyup', function(e) &#123; newObj.text = e.target.value;&#125;); 总结Proxy特点: 可以劫持整个对象，并返回一个新对象 有13种劫持操作 Proxy是es6提供的，兼容性不好,无法用polyfill磨平 友情提示:目标对象内部的this关键字会指向 Proxy 代理]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>数据劫持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular脏值检测]]></title>
    <url>%2F2019%2F09%2F16%2Fangular%E8%84%8F%E5%80%BC%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[一: 概念简介 脏值检测，简单的说就是在MVC的构架中，视图会通过模型的change事件来更新自己。 脏值检测的核心代码是观察者模式的实现，其机制会执行digest循环，在特定UI组件的上下文执行注册的各种表达式。 那么脏值检测在单页应用扮演了什么角色呢？ 为了支持单页SPA应用，angular1引入了指令的概念，能够扩展HTML标签并且封装相关的DOM逻辑，以此来构建组件，组件再组合成一个个网页。angular2也保留了指令的概念。那么angular2和1版本的区别在哪里呢？angular2的指令则是简化版的指令API，能通过属性型的指令给DOM标签添加行为。 而与此同时，组件则可以看做指令API的补充，既可以添加模板，也可以添加行为，组件继承自指令。 123456@Directive(&#123; selector: &apos;[saTooltip]&apos;&#125;)export class Tooltip &#123; //略&#125; 二: angular1中的脏值检测1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt; &lt;!--引入版本为1.5.0--&gt; &lt;script&gt; angular.module(&quot;app&quot;,[]) .controller(&quot;mainCtrl&quot;,function($scope)&#123; $scope.label=&quot;hello world!&quot;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;app&quot; ng-controller=&quot;mainCtrl&quot;&gt; &lt;div&gt; &lt;span&gt;label值:&#123;&#123;label&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;input type=&quot;text&quot; ng-model=&quot;label&quot;/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浏览器结果 angular1的数据绑定，酷炫而神秘！可是它幕后实际发生了什么呢？ (1)首先，在指令ng-model和双大括号(实际上是ng-bind指令)内部绑定了多个watcher(监视器)。 (2)接下来，当指定的事件发生之后，angular循环遍历所有的监视器，并执行对应scope上下文的表达式。这里就是digest循环。 (3)最后，比对两次结果，如果不相同就调用回调函数。 但这种发生特定事件(有可能在框架管理范围内，也可能在范围外部)会调用digest循环有缺点。比如回调函数有setTimeOut定时器，定时器把绑定到Scope上的属性给修改了，那么angular就无法察觉对象的改变了。angular2解决这个问题。 三: angular2更优的脏值检测1.zone.js库 zone.js是angular2的一个库，可以在javascript实现各种分区。分区代表一个执行上下文。angular2利用了zone.js来拦截浏览器中的各种异步事件，然后在正确的时机调用digest循环，完全消除了需要angular开发者显式调用digest循环的情况。 2.单向数据流 在第一章的例子里，label表达式在ng-model指令下发生改变，也会通知label的双大括号表达式改变值，这隐含了指令之间互相影响、有依赖关系。跨监视器的依赖会创建出各种纠缠不清的额数据流，导致最后可能很难追踪，进而导致难以预料的错误。 angular2保留了脏值检测的概念用来检测数据，但强制使用了单向数据流。 实现的方式: 禁止不同的监视器互相依赖，digest循环只要运行一次就好了。 单向数据流好处不仅仅于此，更简单的数据流，而且性能提高了 3.增强angular1的脏值检测 我们说到digest循环有比较的步骤，比较操作的最佳算法是根据表达式返回值的类型进行比较。angular1有的是浅比较，有的是深比较，而且开发者并不能自己预先决定使用哪种比较。angular2团队把比较功能分离到了differ(差异比较器)中，那么开发者就可以通过2个基础类扩展自定义算法了，从而有了对脏值检测机制的完全控制。 ●KeyValueDiffer。键值对型差异比较器。 ●IterableDiffer。迭代型差异比较器。]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>脏值检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读webpack的bundle.js]]></title>
    <url>%2F2019%2F09%2F16%2F%E8%A7%A3%E8%AF%BBwebpack%E7%9A%84bundle%2F</url>
    <content type="text"><![CDATA[可能就是好奇心略重了，读了一下webpack打包后的bundle.js的代码，复杂的模块可能读不懂，但简单的hello world模块我还是能看懂的。没什么目的，就是想通过几个简单的模块，一条简单的webpack命令，一个神奇的bundle.js代码来了解webpack是怎么把遵循commonJs规范的模块应用到浏览器端的。 几个简单的模块： 一条简单的webpack命令： 一个神奇的bundle.js： 无非就是一个立即执行的函数表达式嘛（IIFE），这是JavaScript中常见的独立作用域的方法。这里我将注释简化一下： 1234567891011121314151617181920212223242526272829303132333435363738 1 (function(modules)&#123; 2 //module缓存对象 3 var installedModules = &#123;&#125;; 4 //require函数 5 function __webpack_require__(moduleId)&#123; 6 //检查module是否在cache中 7 if(installedModules[moduleId])&#123; 8 return installedModules[moduleId].exports; 9 &#125;10 //若不在cache中则新建module并放入cache中11 var module = installedModules[moduleId] = &#123;12 exports: &#123;&#125;,13 id: moduleId,14 loaded: false15 &#125;;16 //执行module函数17 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);18 //标记module已经加载19 module.loaded = true;20 //返回module的导出模块21 return module.exports;22 &#125;23 24 //暴露modules对象（__webpack_modules__）25 __webpack_require__.m = modules;26 //暴露modules缓存27 __webpack_require__.c = installedModules;28 //设置webpack公共路径__webpack_public_path__29 __webpack_require__.p = &quot;&quot;;30 //读取入口模块并且返回exports导出31 return __webpack_require__(0);32 33 &#125;)([function(module, exports, __webpack_require__)&#123; /*模块Id为0*/34 var text = __webpack_require__(1);35 console.log(text);36 &#125;,function(module, exports)&#123; /*模块Id为1*/37 module.exports = &apos;Hello world&apos;;38 &#125;]); 这个IIFE接收一个数组作为参数modules，数组的每一项都是一个匿名函数代表一个模块（index.js和hello.js模块）。可是为什么构建命令中只出现了“index.js”呢，这是因为webpack通过静态分析index.js文件得到语法树，递归检测index.js所依赖的模块，以及依赖的依赖，入口模块和所有的依赖模块作为数组中的项，并合并到最终的代码中。 正是由于模块代码被包装成函数后，每个模块的运行时机变的可控，可以决定何时调用（通过 modules[moduleId].call ），而且也有了独立的作用域，定义变量，声明函数都不会污染全局作用域。模块函数的参数列表中除了commonJS规范所要求的 module 与 exports 外，还有 webpack_require 函数，用来替换 require ，作用是声明对其他模块的依赖并获得该模块的 exports （ return installedModules[moduleId].exports 和 return module.exports; ）。而且不需要提供模块的相对路径或其他形式的ID，直接传入该模块在modules列表中索引即可，这样可以省掉模块标识符的解析过程（准确说，webpack是把require模块的解析过程提前到了构建期），从而可以获得更好的运行性能。 程序解读：bundle.js通过 webpack_require(0); 启动整个程序，先检查模块ID = 0是否在缓存对象中，若该模块的缓存存在返回 module.exports 即模块所暴露出来的数据，若该模块的缓存不在则新创建module对象（该module对象作用是用来指向真实模块）并加入到缓存对象中，此时由于module对象和该模块的缓存对象 installedModules[moduleId] 的exports属性为没有数据，所以需要通过执行该模块函数来返回具体require其他模块的数据，传入的上下文对象是 module.exports 和 installedModules[moduleId].exports 所共同指向的一个对象。当程序执行到 var text = webpack_require(1); 时，又会执行 modules[1].call ，然后 module.exports = ‘Hello world’; 将执行 webpack_require(1) 时创建的module1的exports赋值为Hello world，并返回，此时 webpack_require(1) 执行完毕，text为Hello world并打印， webpack_require(0) 执行完毕。这是一个递归的过程，如果还有更多依赖模块的话会更明显。 总结一下，webpack主要做了两部分工作：1.分析得到所有必须模块并合并。2.提供让这些模块有序，正常的执行环境。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析浏览器渲染基本原理]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[大多数设备的刷新频率是60Hz，也就说是浏览器对每一帧画面的渲染工作要在16ms内完成,超出这个时间，页面的渲染就会出现卡顿现象，影响用户体验。前端的用户体验给了前端直观的印象，因此对B/S架构的开发人员来说，熟悉浏览器的内部执行原理显得尤为重要。 1. 浏览器主要组成与浏览器线程1.1 浏览器组件浏览器大体上由以下几个组件组成，各个浏览器可能有一点不同。 界面控件 – 包括地址栏，前进后退，书签菜单等窗口上除了网页显示区域以外的部分 浏览器引擎 – 查询与操作渲染引擎的接口 渲染引擎 – 负责显示请求的内容。比如请求到HTML, 它会负责解析HTML、CSS并将结果显示到窗口中 网络 – 用于网络请求, 如HTTP请求。它包括平台无关的接口和各平台独立的实现 UI后端 – 绘制基础元件，如组合框与窗口。它提供平台无关的接口，内部使用操作系统的相应实现 JS解释器 - 用于解析执行JavaScript代码 数据存储持久层 - 浏览器需要把所有数据存到硬盘上，如cookies。新的HTML5规范规定了一个完整（虽然轻量级）的浏览器中的数据库web database 注意：chrome浏览器与其他浏览器不同，chrome使用多个渲染引擎实例，每个Tab页一个，即每个Tab都是一个独立进程。 1.2 浏览器中的进程与线程Chrome浏览器使用多个进程来隔离不同的网页，在Chrome中打开一个网页相当于起了一个进程，每个tab网页都有由其独立的渲染引擎实例。因为如果非多进程的话，如果浏览器中的一个tab网页崩溃，将会导致其他被打开的网页应用。另外相对于线程，进程之间是不共享资源和地址空间的，所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源，所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。 在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成： GUI 渲染线程GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的，也就是说被冻结了. JavaScript引擎线程JS为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JS是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS在最初就选择了单线程执行。GUI渲染线程与JS引擎线程互斥的，是由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。由于GUI渲染线程与JS执行线程是互斥的关系，当浏览器在执行JS程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 定时触发器线程浏览器定时计数器并不是由JS引擎计数的, 因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。 事件触发线程当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。 异步http请求线程在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理。 2. 渲染过程2.1 渲染流程用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。每次通常渲染不会超过8K的数据块，其中基础的渲染流程图： webkit引擎渲染的详细流程，其他引擎渲染流程稍有不同： 渲染流程有四个主要步骤： 解析HTML生成DOM树 - 渲染引擎首先解析HTML文档，生成DOM树 构建Render树 - 接下来不管是内联式，外联式还是嵌入式引入的CSS样式会被解析生成CSSOM树，根据DOM树与CSSOM树生成另外一棵用于渲染的树-渲染树(Render tree)， 布局Render树 - 然后对渲染树的每个节点进行布局处理，确定其在屏幕上的显示位置 绘制Render树 - 最后遍历渲染树并用UI后端层将每一个节点绘制出来 以上步骤是一个渐进的过程，为了提高用户体验，渲染引擎试图尽可能快的把结果显示给最终用户。它不会等到所有HTML都被解析完才创建并布局渲染树。它会在从网络层获取文档内容的同时把已经接收到的局部内容先展示出来。 2.2 渲染细节1. 生成DOM树DOM树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。DOM树的根节点就是document对象。 DOM树的生成过程中可能会被CSS和JS的加载执行阻塞，具体可以参见下一章。当HTML文档解析过程完毕后，浏览器继续进行标记为deferred模式的脚本加载，然后就是整个解析过程的实际结束触发DOMContentLoaded事件，并在async文档文档执行完之后触发load事件。 2. 生成Render树生成DOM树的同时会生成样式结构体CSSOM（CSS Object Model）Tree，再根据CSSOM和DOM树构造渲染树Render Tree，渲染树包含带有颜色，尺寸等显示属性的矩形，这些矩形的顺序与显示顺序基本一致。从MVC的角度来说，可以将Render树看成是V，DOM树与CSSOM树看成是M，C则是具体的调度者，比HTMLDocumentParser等。 可以这么说，没有DOM树就没有Render树，但是它们之间不是简单的一对一的关系。Render树是用于显示，那不可见的元素当然不会在这棵树中出现了，譬如&lt;head&gt;。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。 3. DOM树与Render树DOM对象类型很丰富，什么head、title、div，而Render树相对来说就比较单一了，毕竟它的职责就是为了以后的显示渲染用嘛。Render树的每一个节点我们叫它渲染器renderer。 一棵Render树大概是酱紫，左边是DOM树，右边是Render树： 从上图我们可以看出，renderer与DOM元素是相对应的，但并不是一一对应，有些DOM元素没有对应的renderer，而有些DOM元素却对应了好几个renderer，对应多个renderer的情况是普遍存在的，就是为了解决一个renderer描述不清楚如何显示出来的问题，譬如有下拉列表的select元素，我们就需要三个renderer：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。 另外，renderer与DOM元素的位置也可能是不一样的。那些添加了float或者position:absolute的元素，因为它们脱离了正常的文档流，构造Render树的时候会针对它们实际的位置进行构造。 4. 布局与绘制上面确定了renderer的样式规则后，然后就是重要的显示元素布局了。当renderer构造出来并添加到Render树上之后，它并没有位置跟大小信息，为它确定这些信息的过程，接下来是布局(layout)。 浏览器进行页面布局基本过程是以浏览器可见区域为画布，左上角为(0,0)基础坐标，从左到右，从上到下从DOM的根节点开始画，首先确定显示元素的大小跟位置，此过程是通过浏览器计算出来的，用户CSS中定义的量未必就是浏览器实际采用的量。如果显示元素有子元素得先去确定子元素的显示信息。 布局阶段输出的结果称为box盒模型（width,height,margin,padding,border,left,top,…），盒模型精确表示了每一个元素的位置和大小，并且所有相对度量单位此时都转化为了绝对单位。 在绘制(painting)阶段，渲染引擎会遍历Render树，并调用renderer的 paint() 方法，将renderer的内容显示在屏幕上。绘制工作是使用UI后端组件完成的。 5. 回流与重绘回流(reflow)：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。reflow 会从&lt;html&gt;这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 重绘(repaint)：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。 每次Reflow，Repaint后浏览器还需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。Reflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。可以在csstrigger上查找某个css属性会触发什么事件。 reflow与repaint的时机： display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。 有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。 3. 关键渲染路径与阻塞渲染在浏览器拿到HTML、CSS、JS等外部资源到渲染出页面的过程，有一个重要的概念关键渲染路径（Critical Rendering Path）。例如为了保障首屏内容的最快速显示，通常会提到一个渐进式页面渲染，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。了解原理可以让我们更好的优化关键渲染路径，从而获得更好的用户体验。 现代浏览器总是并行加载资源，例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。 同时，由于下面两点： CSS 被视为渲染阻塞资源(包括JS)，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕，才会进行下一阶段。 JavaScript 被认为是解释器阻塞资源，HTML解析会被JS阻塞，它不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。 存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外： 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。 JavaScript 可以查询和修改 DOM 与 CSSOM。 CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则： CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。 JavaScript 应尽量少影响 DOM 的构建。 下面来看看 CSS 与 JavaScript 是具体如何阻塞资源的。 3.1 CSS12&lt;style&gt; p &#123; color: red; &#125;&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; 这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。 渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。 最容易想到的当然是精简 CSS 并尽快提供它。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。 123&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 30em) and (orientation: landscape)&quot;&gt; 第一个资源会加载并阻塞。第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。第三个资源提供了媒体查询，会在符合条件时阻塞渲染。 关于CSS加载的阻塞情况： css加载不会阻塞DOM树的解析 css加载会阻塞DOM树的渲染 css加载会阻塞后面js语句的执行 没有js的理想情况下，html与css会并行解析，分别生成DOM与CSSOM，然后合并成Render Tree，进入Rendering Pipeline；但如果有js，css加载会阻塞后面js语句的执行，而（同步）js脚本执行会阻塞其后的DOM解析（所以通常会把css放在头部，js放在body尾） 3.2 JavaScriptJavaScript 的情况比 CSS 要更复杂一些。如果没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的HTML元素之前，也就是说不等待后续载入的HTML元素，读到就加载并执行。观察下面的代码： 123456789&lt;p&gt;Do not go gentle into that good night,&lt;/p&gt;&lt;script&gt;console.log(&quot;inline1&quot;)&lt;/script&gt;&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;p&gt;Rage, rage against the dying of the light.&lt;/p&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;&lt;script&gt;console.log(&quot;inline2&quot;)&lt;/script&gt;&lt;p&gt;Rage, rage against the dying of the light.&lt;/p&gt; 这里的 script 标签会阻塞 HTML 解析，无论是不是 inline-script。上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打断一次（加载、执行）。 解析过程中无论遇到的JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒JavaScript解析器，就会进行暂停 (blocked )浏览器解析HTML，并等到 CSSOM 构建完毕，才去执行js脚本。因为脚本中可能会操作DOM元素，而如果在加载执行脚本的时候DOM元素并没有被解析，脚本就会因为DOM元素没有生成取不到响应元素，所以实际工程中，我们常常将资源放到文档底部。 3.3 改变脚本加载次序defer与asyncdefer 与 async 可以改变之前的那些阻塞情形，这两个属性都会使 script 异步加载，然而执行的时机是不一样的。注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。 123&lt;script async&gt;console.log(&quot;1&quot;)&lt;/script&gt;&lt;script defer&gt;console.log(&quot;2&quot;)&lt;/script&gt;&lt;script&gt;console.log(&quot;3&quot;)&lt;/script&gt; 上面脚本会按需输出 1 2 3，故，下面两节讨论的内容都是针对设置了 src 属性的 script 标签。 先放个熟悉的图~ 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 defer123&lt;script src=&quot;app1.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;app2.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;app3.js&quot; defer&gt;&lt;/script&gt; defer 属性表示延迟执行引入 JavaScript，即 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，再触发DOMContentLoaded(初始的 HTML 文档被完全加载和解析完成之后触发，无需等待样式表图像和子框架的完成加载) 事件。 defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 asyncasync 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发(HTML解析完成事件)之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 从上一段也能推出，多个 async-script 的执行顺序是不确定的，谁先加载完谁执行。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true。 document.createElement使用 document.createElement 创建的 script 默认是异步的，示例如下。 1console.log(document.createElement(&quot;script&quot;).async); // true 所以，通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。如果想同步执行，需要将 async 属性人为设置为 false。 如果使用 document.createElement 创建 link 标签会怎样呢？ 1234const style = document.createElement(&quot;link&quot;);style.rel = &quot;stylesheet&quot;;style.href = &quot;index.css&quot;;document.head.appendChild(style); // 阻塞？ 其实这只能通过试验确定，已知的是，Chrome 中已经不会阻塞渲染，Firefox、IE 在以前是阻塞的，现在会怎样目前不太清楚。 4. 优化渲染性能结合渲染流程，可以针对性的优化渲染性能： 优化JS的执行效率 降低样式计算的范围和复杂度 避免大规模、复杂的布局 简化绘制的复杂度、减少绘制区域 优先使用渲染层合并属性、控制层数量 对用户输入事件的处理函数去抖动（移动设备） 这里主要参考Google的浏览器渲染性能的基础讲座，想看更详细内容可以去瞅瞅~ 4.1 优化JS的执行效率1. 动画实现使用requestAnimationFramesetTimeout(callback)和setInterval(callback)无法保证callback函数的执行时机，很可能在帧结束的时候执行，从而导致丢帧，如下图： requestAnimationFrame(callback)可以保证callback函数在每帧动画开始的时候执行。注意：jQuery3.0.0以前版本的animate函数就是用setTimeout来实现动画，可以通过jquery-requestAnimationFrame这个补丁来用requestAnimationFrame替代setTimeout 2. 长耗时的JS代码放到Web Workers中执行JS代码运行在浏览器的主线程上，与此同时，浏览器的主线程还负责样式计算、布局、绘制的工作，如果JavaScript代码运行时间过长，就会阻塞其他渲染工作，很可能会导致丢帧。前面提到每帧的渲染应该在16ms内完成，但在动画过程中，由于已经被占用了不少时间，所以JavaScript代码运行耗时应该控制在3-4毫秒。如果真的有特别耗时且不操作DOM元素的纯计算工作，可以考虑放到Web Workers中执行。 12345678910var dataSortWorker = new Worker(&quot;sort-worker.js&quot;);dataSortWorker.postMesssage(dataToSort);// 主线程不受Web Workers线程干扰dataSortWorker.addEventListener(&apos;message&apos;, function(evt) &#123; var sortedData = e.data; // Web Workers线程执行结束 // ...&#125;); 3. 拆分操作DOM元素的任务，分别在多个frame完成由于Web Workers不能操作DOM元素的限制，所以只能做一些纯计算的工作，对于很多需要操作DOM元素的逻辑，可以考虑分步处理，把任务分为若干个小任务，每个任务都放到requestAnimationFrame中回调执行 12345678910111213var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);requestAnimationFrame(processTaskList);function processTaskList(taskStartTime) &#123; var nextTask = taskList.pop(); // 执行小任务 processTask(nextTask); if (taskList.length &gt; 0) &#123; requestAnimationFrame(processTaskList); &#125;&#125; 4. 使用Chrome DevTools的Timeline来分析JavaScript的性能打开Chrome DevTools &gt; Timeline &gt; JS Profile，录制一次动作，然后分析得到的细节信息，从而发现问题并修复问题。 4.2 降低样式计算的范围和复杂度添加或移除一个DOM元素、修改元素属性和样式类、应用动画效果等操作，都会引起DOM结构的改变，从而导致浏览器要repaint或者reflow。那么这里可以采取一些措施。 1. 降低样式选择器的复杂度尽量保持class的简短，或者使用Web Components框架。 123.box:nth-last-child(-n+1) .title &#123;&#125;// 改善后.final-box-title &#123;&#125; 2. 减少需要执行样式计算的元素个数由于浏览器的优化，现代浏览器的样式计算直接对目标元素执行，而不是对整个页面执行，所以我们应该尽可能减少需要执行样式计算的元素的个数。 4.3 避免大规模、复杂的布局布局就是计算DOM元素的大小和位置的过程，如果你的页面中包含很多元素，那么计算这些元素的位置将耗费很长时间。布局的主要消耗在于：1. 需要布局的DOM元素的数量；2. 布局过程的复杂程度 1. 尽可能避免触发布局当你修改了元素的属性之后，浏览器将会检查为了使这个修改生效是否需要重新计算布局以及更新渲染树，对于DOM元素的几何属性修改，比如width/height/left/top等，都需要重新计算布局。对于不能避免的布局，可以使用Chrome DevTools工具的Timeline查看布局的耗时，以及受影响的DOM元素数量。 2. 使用flexbox替代老的布局模型老的布局模型以相对/绝对/浮动的方式将元素定位到屏幕上，而Floxbox布局模型用流式布局的方式将元素定位到屏幕上。通过一个小实验可以看出两种布局模型的性能差距，同样对1300个元素布局，浮动布局耗时14.3ms，Flexbox布局耗时3.5ms。IE10+支持。 3. 避免强制同步布局事件的发生根据渲染流程，JS脚本是在layout之前执行，但是我们可以强制浏览器在执行JS脚本之前先执行布局过程，这就是所谓的强制同步布局。 1234567891011121314151617181920requestAnimationFrame(logBoxHeight);// 先写后读，触发强制布局function logBoxHeight() &#123; // 更新box样式 box.classList.add(&apos;super-big&apos;); // 为了返回box的offersetHeight值 // 浏览器必须先应用属性修改，接着执行布局过程 console.log(box.offsetHeight);&#125;// 先读后写，避免强制布局function logBoxHeight() &#123; // 获取box.offsetHeight console.log(box.offsetHeight); // 更新box样式 box.classList.add(&apos;super-big&apos;);&#125; 在JS脚本运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧的值。因此，如果你在当前帧获取属性之前又对元素节点有改动，那就会导致浏览器必须先应用属性修改，结果执行布局过程，最后再执行JS逻辑。 4. 避免连续的强制同步布局发生如果连续快速的多次触发强制同步布局，那么结果更糟糕。比如下面的例子，获取box的属性，设置到paragraphs上，由于每次设置paragraphs都会触发样式计算和布局过程，而下一次获取box的属性必须等到上一步设置结束之后才能触发。 1234567891011121314function resizeWidth() &#123; // 会让浏览器陷入&apos;读写读写&apos;循环 for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + &apos;px&apos;; &#125;&#125;// 改善后方案var width = box.offsetWidth;function resizeWidth() &#123; for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + &apos;px&apos;; &#125;&#125; 注意：可以使用FastDOM来确保读写操作的安全，从而帮你自动完成读写操作的批处理，还能避免意外地触发强制同步布局或快速连续布局，消除大量操作DOM的时候的布局抖动。 4.4 简化绘制的复杂度、减少绘制区域Paint就是填充像素的过程，通常这个过程是整个渲染流程中耗时最长的一环，因此也是最需要避免发生的一环。如果Layout被触发，那么接下来元素的Paint一定会被触发。当然纯粹改变元素的非几何属性，也可能会触发Paint，比如背景、文字颜色、阴影效果等。 1. 提升移动或渐变元素的绘制层绘制并非总是在内存中的单层画面里完成的，实际上，浏览器在必要时会将一帧画面绘制成多层画面，然后将这若干层画面合并成一张图片显示到屏幕上。这种绘制方式的好处是，使用transform来实现移动效果的元素将会被正常绘制，同时不会触发其他元素的绘制。 2. 减少绘制区域，简化绘制的复杂度浏览器会把相邻区域的渲染任务合并在一起进行，所以需要对动画效果进行精密设计，以保证各自的绘制区域不会有太多重叠。另外可以实现同样效果的不同方式，应该采用性能更好的那种。 3. 通过Chrome DevTools来分析绘制复杂度和时间消耗，尽可能降低这些指标打开DevTools，在弹出的面板中，选中More Tools &gt; Rendering选项卡下的Paint flashing，这样每当页面发生绘制的时候，屏幕就会闪现绿色的方框。通过该工具可以检查Paint发生的区域和时机是不是可以被优化。通过Chrome DevTools中的Timeline &gt; Paint选项可以查看更细节的Paint信息 4.5 优先使用渲染层合并属性、控制层数量1. 使用transform/opacity实现动画效果使用transform/opacity实现动画效果，会跳过渲染流程的布局和绘制环节，只做渲染层的合并。 Type Func Position transform: translate(-px,-px) Scale transform: scale(-) Rotation transform: rotate(-deg) Skew transform: skew(X/Y)(-deg) Matrix transform: matrix(3d)(..) Opacity opacity: 0-1 使用transform/opacity的元素必须独占一个渲染层，所以必须提升该元素到单独的渲染层。 2. 提升动画效果中的元素应用动画效果的元素应该被提升到其自有的渲染层，但不要滥用。在页面中创建一个新的渲染层最好的方式就是使用CSS属性will-change，对于目前还不支持will-change属性、但支持创建渲染层的浏览器，可以通过3D transform属性来强制浏览器创建一个新的渲染层。需要注意的是，不要创建过多的渲染层，这意味着新的内存分配和更复杂的层管理。注意，IE11，Edge17都不支持这一属性。 1234.moving-element &#123; will-change: transform; transform: translateZ(0);&#125; 3. 管理渲染层、避免过多数量的层尽管提升渲染层看起来很诱人，但不能滥用，因为更多的渲染层意味着更多的额外的内存和管理资源，所以当且仅当需要的时候才为元素创建渲染层。 1234* &#123; will-change: transform; transform: translateZ(0);&#125; 4. 使用Chrome DevTools来了解页面的渲染层情况开启Timeline &gt; Paint选项，然后录制一段时间的操作，选择单独的帧，看到每个帧的渲染细节，在ESC弹出框有个Layers选项，可以看到渲染层的细节，有多少渲染层，为何被创建？ 4.6 对用户输入事件的处理函数去抖动（移动设备）用户输入事件处理函数会在运行时阻塞帧的渲染，并且会导致额外的布局发生。 1. 避免使用运行时间过长的输入事件处理函数理想情况下，当用户和页面交互，页面的渲染层合并线程将接收到这个事件并移动元素。这个响应过程是不需要主线程参与，不会导致JavaScript、布局和绘制过程发生。但是如果被触摸的元素绑定了输入事件处理函数，比如touchstart/touchmove/touchend，那么渲染层合并线程必须等待这些被绑定的处理函数执行完毕才能执行，也就是用户的滚动页面操作被阻塞了，表现出的行为就是滚动出现延迟或者卡顿。 简而言之就是你必须确保用户输入事件绑定的任何处理函数都能够快速的执行完毕，以便腾出时间来让渲染层合并线程完成他的工作。 2. 避免在输入事件处理函数中修改样式属性输入事件处理函数，比如scroll/touch事件的处理，都会在requestAnimationFrame之前被调用执行。因此，如果你在上述输入事件的处理函数中做了修改样式属性的操作，那么这些操作就会被浏览器暂存起来，然后在调用requestAnimationFrame的时候，如果你在一开始就做了读取样式属性的操作，那么将会触发浏览器的强制同步布局操作。 3. 对滚动事件处理函数去抖动通过requestAnimationFrame可以对样式修改操作去抖动，同时也可以使你的事件处理函数变得更轻 12345678910111213function onScroll(evt) &#123; // Store the scroll value for laterz. lastScrollY = window.scrollY; // Prevent multiple rAF callbacks. if (scheduledAnimationFrame) &#123; return; &#125; scheduledAnimationFrame = true; requestAnimationFrame(readAndUpdatePage);&#125;window.addEventListener(&apos;scroll&apos;, onScroll);]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的LHS和RHS查询]]></title>
    <url>%2F2019%2F09%2F16%2FJavaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[问题来源于《你不知道的JavaScript（上卷）》，文章部分论述截自原书。 简述编译原理JavaScript通常会被归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统上进行移植。 在传统编译语言的流程中，程序中的一段源代码在执行前会经历三个步骤，统称为“编译”。 分词 / 词法分析 解析 / 语法分析 代码生成 与其他语言不同，JavaScript的编译过程不是发生在构建之前的。对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。 举个栗子，var a = 2; JavaScript引擎会将它分为几步完成呢？ 答案是两步，JavaScript 会将其看成两句声明：var a; 和 a = 2;。第一个定义声明在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。 下面是原书对这句声明的拆解分析： 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在引用域中查找该变量，如果能够找到就会对它赋值。 而要讲的LHS 和 RHS 就是上面说的对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行。 LHS 和 RHSLHS(Left-hand Side)引用和RHS(Right-hand Side)引用。通常是指等号（赋值运算）的左右边的引用。我们来看下面这句代码： 1console.log(a); 这里对a的引用是一个RHS引用，因为这里a并没有赋予任何值，我们只是想查找并取得a的值，然后将它打印出来。 1a = 2; 这里对a的引用是一个LHS引用，因为我们并不关心当前的值是什么，只是想要为赋值操作找到目标。 注：LHS和RHS的含义是“赋值操作的左侧和右侧”并不一定意味这就是”=”的左侧和右侧。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。 这里再举一个较复杂的例子：（找出所有的LHS查询和所有的RHS查询） 12345function foo(a) &#123;var b = a;return a + b;&#125;var c = foo(2); 这里一共有3个LHS查询和4个RHS查询，这里我们都来做个分析。 LHS： 第6行的 c = ...，c 在赋值操作的左边，所以对 c 需要 LHS 查询。 隐藏着的 a = 2（隐式变量分配）,在调用 foo(2) 时，需要将实参2赋值给形参a，所以对 a 需要 LHS 查询。 第2行的b = ..., 解释同 1。 RHS： 第6行的 c = foo(2)，foo(2) 在赋值操作的右边，需要知道 foo(2)的值，对 foo(2) 需要 RHS 查询。 第2行的b = a， a 在赋值操作的右边，需要知道 a的值，对 a 需要 RHS 查询。 第3行的 reutrn a + b;， 需要知道 a 和 b 的值， 分别对 a 和 b 都进行 RHS 查询。 小结：如果查找的目的是对变量进行赋值，那么就会使用LHS查询； 如果目的是获取变量的值，就会使用RHS查询。 区分 LHS 和 RHS 的重要性 因为在变量还没有声明(在任何作用域中都无法找到该变量)情况下，这两种查询行为是不一样的。 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说他们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一次作用域，最后抵达全局作用域，无论找到或没找到都将停止。 借用书中的一张图，将作用域链比喻成一个建筑，在对上面的论述进行一次转换。 （对作用域链的具体介绍可以移步 理解 JavaScript 的作用域链） 这个建筑代表储蓄中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所在的位置。建筑的顶层代表全局作用域。 LHS 和 RHS 引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。 总结:不成功的RHS引用会导致抛出 ReferenceError 异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>LHS和RHS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈setTimeout的作用域以及this的指向问题]]></title>
    <url>%2F2019%2F09%2F16%2F%E8%B0%88%E8%B0%88setTimeout%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8Athis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[setTimeout的常见用法是让某个方法延迟执行。我们知道，setTimeout方法是挂在window对象下的。《JavaScript高级程序设计》第二版中，写到：“超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined”。在这里，我们只讨论非严格模式。 setTimeout接受两个参数，第一个是要执行的代码或函数，第二个是延迟的时间。 一、先说结论：setTimeout中所执行函数中的this，永远指向window！！注意是要延迟执行的函数中的this哦！！ 直接使用，代码1.1： 1setTimeout("alert(this)", 1);// [object Window] 在一个对象中调用setTimeout试试，代码1.2： 123456var obj = &#123; say: function () &#123; setTimeout("alert('in obj ' + this)", 0) &#125; &#125; obj.say(); // in obj [object Window] 将执行的代码换成匿名函数试试，代码1.3： 12345678varobj = &#123; say: function () &#123; setTimeout(function () &#123; alert(this) &#125;, 0) &#125; &#125; obj.say(); // [object Window] 换成函数引用再试试吧，代码1.4： 123456789function talk() &#123; alert(this);&#125;var obj = &#123; say: function() &#123; setTimeout(talk, 0) &#125;&#125;obj.say(); // [object Window] 恩，貌似得到的结论是正确的，setTimeout中的延迟执行函数中的this指向了window。这里我反复的强调，是延迟执行函数中的this，是因为，我们经常会面对两个this。一个是setTimeout调用环境中的this，一个就是延迟执行函数中的this。这两个this有时候是不同的。有些不放心？？再多写一些代码测试一下！ 二、setTimeout中的两个this到底指向谁？？为了便于区分，我们把setTimeout调用环境下的this称之为第一个this，把延迟执行函数中的this称之为第二个this，并在代码注释中标出来，方便您区分。先说得出的结论：第一个this的指向是需要根据上下文来确定的，默认为window；第二个this就是指向window。然后我们通过代码来验证下。 函数作为方法调用还是构造函数调用，this是不同的。先看代码，代码2.1： 12345678910function Foo() &#123; this.value = 42; this.method = function() &#123; // this 指向全局对象 alert(this) // 输出window 第二个this alert(this.value); // 输出：undefined 第二个this &#125;; setTimeout(this.method, 500); // this指向Foo的实例对象 第一个this&#125;new Foo(); 我们new了一个Foo对象，那么this.method中的this指向的是new的对象，否则无法调用method方法。但是进了method方法后，方法中的this又指向了window，因此this.value的值为undefined。 我们在外层添加一段代码，再看看，代码2.2： 123456789101112var value=33; function Foo() &#123; this.value = 42; this.method = function() &#123; // this 指向全局对象 alert(this) // 输出window 第二个this alert(this.value); // 输出：33 第二个this &#125;; setTimeout(this.method, 500); // 这里的this指向Foo的实例对象 第一个this&#125;new Foo(); 从这里，可以明显的看到，method方法中的this指向的是window，因为可以输出外层的value值。那为什么setTimeout中的this指向的是Foo的实例对象呢？ 我觉得代码2.2就等价于下面的代码，如代码2.3： 1234567var value=33; function Foo() &#123; this.value = 42; setTimeout(function()&#123;alert(this);alert(this.value)&#125;, 500); // 先后输出 window 33 这里是第二个this&#125;new Foo(); setTimeout中的第一个参数就是一个单纯的函数的引用而已，而函数中的this仍然指向的是window。在setTimeout(this.method, time) 中的this是可以根据上下文而改变的，其最终的目的是要得到一个函数指针。我们再来验证一下，看代码2.4: 12345678910function method() &#123; alert(this.value); // 输出 42 第二个this&#125; function Foo() &#123; this.value = 42; setTimeout(this.method, 500); // 这里this指向window 第一个this&#125; Foo(); 这次我们将Foo当成方法直接执行，method方法放到外层，即挂在window上面。而this则指向了window，因此可以调用method方法。method方法中的this仍然指向window，而Foo()执行的时候，对window.value进行了赋值(this.value=42)，因此输出了42。 三、实践。知道了得出的结论，我们来阅读一下比较奇葩的一些代码，进行验证。 首先在一个函数中，调用setTimeout。代码3.1： 12345678910var test = "in the window"; setTimeout(function() &#123;alert('outer ' + test)&#125;, 0); // 输出 outer in the window ，默认在window的全局作用域下 function f() &#123; var test = 'in the f!'; // 局部变量，window作用域不可访问 setTimeout('alert("inner " + test)', 0); // 输出 outer in the window, 虽然在f方法的中调用，但执行代码(字符串形式的代码)默认在window全局作用域下，test也指向全局的test&#125; f(); 在f方法中，setTimeout中的test的值是外层的test，而不是f作用域中的test。再看代码3.2： 12345678910var test = "in the window"; setTimeout(function() &#123;alert('outer' + test)&#125;, 0); // outer in the window ，没有问题，在全局下调用，访问全局中的test function f() &#123; var test = 'in the f!'; setTimeout(function()&#123;alert('inner '+ test)&#125;, 0); // inner in the f! 有问题，不是说好了执行函数中的this指向的是window吗？那test也应该对应window下的值才对，怎么test的值却是 f()中的值呢？？？？&#125; f(); 按照前面的经验，f中的setTimeout中的test也应该明明应该是指向外层的test才对吧？？？我们注意到，这个f里面的setTimeout中的第一个参数是一个匿名函数，这是上面两端代码最大的不同。而只要是函数就有它的作用域，我们可以将上面的代码替换成下面的代码3.3： 12345678910111213var test = "in the window"; setTimeout(function() &#123;alert('outer ' + test)&#125;, 0); // in the window function f() &#123; var test = 'in the f!'; function ff() &#123;alert('inner ' + test)&#125; // 能访问到f中的test局部变量 setTimeout(ff, 0); // inner in the f!&#125; f(); 再看一段更清晰的代码，3.4： 1234567var value=33; function Foo() &#123; var value = 42; setTimeout(function()&#123;alert(value);alert(this.value)&#125;, 500); // 先后输出 42 然后输出33 这里的this是第二个this&#125;new Foo(); 可以确定，延迟执行函数中的this的确是指向了window，毫无疑问，上面的所有代码都可以验证哈。但是延迟执行函数中的其他变量需要根据上下文来确认。 修改代码3.4为3.5，去掉匿名函数的调用方式，会更加清晰： 1234567891011var value=33; function Foo() &#123; var value = 42; function ff() &#123; alert(value); // 42 alert(this.value); // 33 &#125; setTimeout(ff, 500); // 先后输出 42 33 &#125;Foo(); // 直接执行，跟普通函数没有区别 因此，如果去掉Foo中的value=42的话，那么value的值等于多少呢？undefined还是外层的33？？请看3.5： 12345678910var value=33; function Foo() &#123; function ff() &#123; alert(value); // 输出33 alert(this.value); // 输出33 this指向window &#125; setTimeout(ff, 500); // 先后输出 33 33&#125;Foo(); 没错，就是外层的33，因为ff可以访问到window下的value值，就如同setTimeout中的匿名函数一样。 最后，我们通过对象的方式进行调用，代码3.6： 12345678910111213var obj = &#123; name: 'hutaoer', say: function() &#123; var self = this; setTimeout(function()&#123; alert(self); // 输出 object ，指向obj alert(this); // 第二个this，指向window，我心永恒，从未改变 alert(self.name) // 输出 hutaoer &#125;, 0) &#125;&#125; obj.say(); 最后，如果您到看懂了上面的例子，那么我们可以回顾一下得出的一些结论咯： 一、setTimeout中的延迟执行代码中的this永远都指向window 二、setTimeout(this.method, time)这种形式中的this，即上文中提到的第一个this，是根据上下文来判断的，默认为全局作用域，但不一定总是处于全局下，具体问题具体分析。 三、setTimeout(匿名函数, time)这种形式下，匿名函数中的变量也需要根据上下文来判断，具体问题具体分析。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅拷贝与深拷贝]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[JS 中有一些基本类型像是Number、String、Boolean，而对象就是像这样的东西{ name: ‘Larry’, skill: ‘Node.js’ }，对象跟基本类型最大的不同就在于他们的传值方式。 基本类型是按值传递，像是这样：在修改a时并不会改到b 12345var a = 25;var b = a;b = 18;console.log(a);//25console.log(b);//18 但对象就不同，对象传的是按引用传值： 12345var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;var obj2 = obj1;obj2.b = 100;console.log(obj1);// &#123; a: 10, b: 100, c: 30 &#125;, b 被改到了console.log(obj2);// &#123; a: 10, b: 100, c: 30 &#125; 复制一份obj1叫做obj2，然后把obj2.b改成100，但却不小心改到obj1.b，因为他们根本是同一个对象，这就是所谓的浅拷贝。 要避免这样的错误发生就要写成这样： 12345var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;var obj2 = &#123; a: obj1.a, b: obj1.b, c: obj1.c &#125;;obj2.b = 100;console.log(obj1);// &#123; a: 10, b: 20, c: 30 &#125;, b 沒被改到console.log(obj2);// &#123; a: 10, b: 100, c: 30 &#125; 这样就是深拷贝，不会改到原本的obj1。 浅拷贝(Shallow Copy) VS 深拷贝(Deep Copy) 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 浅拷贝的实现方式也就是简单地复制而已 1、简单地复制语句 1234567891011121314151617181920212223242526function simpleClone(initalObj) &#123; var obj = &#123;&#125;; for (var i in initalObj) &#123; obj[i] = initalObj[i]; &#125; return obj; &#125; var obj = &#123; a: "hello", b: &#123;a: "world", b: 21&#125;, c: ["Bob", "Tom", "Jenny"], d: function () &#123; alert("hello world"); &#125; &#125; var cloneObj = simpleClone(obj); console.log(cloneObj.b); console.log(cloneObj.c); console.log(cloneObj.d); cloneObj.b.a = "changed"; cloneObj.c = [1, 2, 3]; cloneObj.d = function () &#123; alert("changed"); &#125;; console.log(obj.b); console.log(obj.c); console.log(obj.d); 结果为： 2、Object.assign() Object.assign是ES6的新函数。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 1Object.assign(target, ...sources) 参数： target：目标对象。sources：任意多个源对象。返回值：目标对象会被返回。 1234var obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;;var initalObj = Object.assign(&#123;&#125;, obj);initalObj.a.a = "changed";console.log(obj.a.a); // "changed" 兼容性： 需要注意的是： Object.assign()可以处理一层的深度拷贝，如下： 12345var obj1 = &#123;a: 10, b: 20, c: 30&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj2.b = 100;console.log(obj1);// &#123; a: 10, b: 20, c: 30 &#125; , 沒被改到console.log(obj2); // &#123; a: 10, b: 100, c: 30 &#125; 深拷贝的实现方式要完全复制又不能修改到原对象，这时候就要用 Deep Copy，这里会介绍几种Deep Copy 的方式。 1、手动复制 把一个对象的属性复制给另一个对象的属性 12345var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;var obj2 = &#123; a: obj1.a, b: obj1.b, c: obj1.c &#125;;obj2.b = 100;console.log(obj1);// &#123; a: 10, b: 20, c: 30 &#125;, 沒被改到console.log(obj2);// &#123; a: 10, b: 100, c: 30 &#125; 但这样很麻烦，要一个一个自己复制；而且这样的本质也不能算是 Deep Copy，因为对象里面也可能回事对象，如像下面这个状况： 1234567var obj1 = &#123; body: &#123; a: 10 &#125; &#125;;var obj2 = &#123; body: obj1.body &#125;;obj2.body.a = 20;console.log(obj1);// &#123; body: &#123; a: 20 &#125; &#125;,被改到了console.log(obj2);// &#123; body: &#123; a: 20 &#125; &#125;console.log(obj1 === obj2); // falseconsole.log(obj1.body === obj2.body); // true 虽然obj1跟obj2是不同对象，但他们会共享同一个obj1.body，所以修改obj2.body.a时也会修改到旧的。 2、对象只有一层的话可以使用上面的：Object.assign()函数 1Object.assign(&#123;&#125;, obj1)`的意思是先建立一个空对象&#123;&#125;，接着把`obj1`中所有的属性复制过去，所以`obj2`会长得跟`obj1`一样，这时候再修改`obj2.b`也不会影响`obj1。 因为Object.assign跟我们手动复制的效果相同，所以一样只能处理深度只有一层的对象，没办法做到真正的 Deep Copy。不过如果要复制的对象只有一层的话可以考虑使用它。 3、转成 JSON 再转回来 用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。 12345678var obj1 = &#123; body: &#123; a: 10 &#125; &#125;;var obj2 = JSON.parse(JSON.stringify(obj1));obj2.body.a = 20;;console.log(obj1);// &#123; body: &#123; a: 10 &#125; &#125; //沒被改到console.log(obj2);// &#123; body: &#123; a: 20 &#125; &#125;console.log(obj1 === obj2);// falseconsole.log(obj1.body === obj2.body);// false //这样做是真正的Deep Copy，这种方法简单易用。 但是这种方法也有不少坏处，譬如它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。 这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp对象是无法通过这种方式深拷贝。 也就是说，只有可以转成JSON格式的对象才可以这样用，像function没办法转成JSON。 1234var obj1 = &#123; fun: function()&#123; console.log(123) &#125; &#125;;var obj2 = JSON.parse(JSON.stringify(obj1));console.log(typeof obj1.fun);// 'function'console.log(typeof obj2.fun);// 'undefined', 没复制 要复制的function会直接消失，所以这个方法只能用在单纯只有数据的对象。 4、递归拷贝 1234567891011121314151617function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; if (typeof initalObj[i] === 'object') &#123; obj[i] = (initalObj[i].constructor === Array) ? [] : &#123;&#125;; arguments.callee(initalObj[i], obj[i]); &#125; else &#123; obj[i] = initalObj[i]; &#125; &#125; return obj; &#125; var str = &#123;&#125;; var obj = &#123;a: &#123;a: "hello", b: 21&#125;&#125;; deepClone(obj, str); console.log(str.a); 上述代码确实可以实现深拷贝。但是当遇到两个互相引用的对象，会出现死循环的情况。 为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否相互引用对象，如果是则退出循环。 改进版代码如下： 1234567891011121314151617181920function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if (prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : &#123;&#125;; arguments.callee(prop, obj[i]); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj; &#125; var str = &#123;&#125;; var obj = &#123;a: &#123;a: "hello", b: 21&#125;&#125;; deepClone(obj, str); console.log(str.a); 5、使用Object.create()方法 直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。 12345678910111213141516function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if (prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] :Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj; &#125; 6、jquery jquery 有提供一个$.extend可以用来做 Deep Copy。 1234var $ = require('jquery');var obj1 = &#123;a: 1, b: &#123;f: &#123;g: 1&#125;&#125;, c: [1, 2, 3]&#125;;var obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f);// false 7、lodash 另外一个很热门的函数库lodash，也有提供_.cloneDeep用来做 Deep Copy。 1234var _ = require('lodash'); var obj1 = &#123;a: 1, b: &#123;f: &#123;g: 1&#125;&#125;, c: [1, 2, 3]&#125;; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f);// false 这个性能还不错，使用起来也很简单。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>浅拷贝与深拷贝</tag>
      </tags>
  </entry>
</search>
