---
title: '浅拷贝与深拷贝'
date: 2019-09-16 11:50:03
tags:
copyright:
categories:
---

 JS 中有一些基本类型像是`Number`、`String`、`Boolean，`而对象就是像这样的东西{ name: 'Larry', skill: 'Node.js' }，对象跟基本类型最大的不同就在于他们的传值方式。

基本类型是按值传递，像是这样：在修改`a`时并不会改到`b`

```javascript
var a = 25;
var b = a;
b = 18;
console.log(a);//25
console.log(b);//18
```

但对象就不同，对象传的是按引用传值：

```javascript
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = obj1;
obj2.b = 100;
console.log(obj1);// { a: 10, b: 100, c: 30 }, b 被改到了
console.log(obj2);// { a: 10, b: 100, c: 30 }
```

复制一份`obj1`叫做`obj2，`然后把`obj2.b`改成`100，`但却不小心改到`obj1.b，`因为他们根本是同一个对象，这就是所谓的浅拷贝。

要避免这样的错误发生就要写成这样：

```javascript
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c };
obj2.b = 100;
console.log(obj1);// { a: 10, b: 20, c: 30 }, b 沒被改到
console.log(obj2);// { a: 10, b: 100, c: 30 }
```

这样就是深拷贝，不会改到原本的`obj1。`

## **浅拷贝(Shallow Copy) VS 深拷贝(Deep Copy)**

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTAwNTM1NC8yMDE2MTIvMTAwNTM1NC0yMDE2MTIyNDE2MjU1ODU4OS0zMTk4MjM5NS5wbmc?x-oss-process=image/format,png)![Click and drag to move](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

## 浅拷贝的实现方式

也就是简单地复制而已

**1、简单地复制语句**

```javascript
  function simpleClone(initalObj) {
        var obj = {};
        for (var i in initalObj) {
            obj[i] = initalObj[i];
        }
        return obj;
    }

    var obj = {
        a: "hello", b: {a: "world", b: 21}, c: ["Bob", "Tom", "Jenny"], 
        d: function () {
            alert("hello world");
        }
    }
    var cloneObj = simpleClone(obj);
    console.log(cloneObj.b);
    console.log(cloneObj.c);
    console.log(cloneObj.d);
    cloneObj.b.a = "changed";
    cloneObj.c = [1, 2, 3];
    cloneObj.d = function () {
        alert("changed");
    };
    console.log(obj.b);
    console.log(obj.c);
    console.log(obj.d);
```

结果为：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTAwNTM1NC8yMDE2MTIvMTAwNTM1NC0yMDE2MTIyNDE5MDExNjk0OC0xOTEwNzg2ODI5LnBuZw?x-oss-process=image/format,png)![Click and drag to move](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**2、Object.assign()**

`Object.assign是ES6的新函数。Object.assign()` 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 `Object.assign()` 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。

```javascript
Object.assign(target, ...sources)
```

参数：

target：目标对象。
sources：任意多个源对象。
返回值：目标对象会被返回。

```javascript
var obj = { a: {a: "hello", b: 21} };
var initalObj = Object.assign({}, obj);
initalObj.a.a = "changed";
console.log(obj.a.a); // "changed"
```

兼容性：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTAwNTM1NC8yMDE2MTIvMTAwNTM1NC0yMDE2MTIyNDE5MTAzMzA3My0zNjE1NjE2NjkucG5n?x-oss-process=image/format,png)![Click and drag to move](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

需要注意的是：

Object.assign()可以处理一层的深度拷贝，如下：

```javascript
var obj1 = {a: 10, b: 20, c: 30};
var obj2 = Object.assign({}, obj1);
obj2.b = 100;
console.log(obj1);// { a: 10, b: 20, c: 30 } , 沒被改到
console.log(obj2); // { a: 10, b: 100, c: 30 }
```

## 深拷贝的实现方式

要完全复制又不能修改到原对象，这时候就要用 Deep Copy，这里会介绍几种Deep Copy 的方式。

**1、手动复制**

把一个对象的属性复制给另一个对象的属性

```javascript
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c };
obj2.b = 100;
console.log(obj1);// { a: 10, b: 20, c: 30 }, 沒被改到
console.log(obj2);// { a: 10, b: 100, c: 30 }
```

但这样很麻烦，要一个一个自己复制；而且这样的本质也不能算是 Deep Copy，因为对象里面也可能回事对象，如像下面这个状况：

```javascript
var obj1 = { body: { a: 10 } };
var obj2 = { body: obj1.body };
obj2.body.a = 20;
console.log(obj1);// { body: { a: 20 } },被改到了
console.log(obj2);// { body: { a: 20 } }
console.log(obj1 === obj2); // false
console.log(obj1.body === obj2.body); // true
```
虽然`obj1`跟`obj2`是不同对象，但他们会共享同一个`obj1.body`，所以修改`obj2.body.a`时也会修改到旧的。

**2、对象只有一层的话可以使用上面的：Object.assign()函数**

```
Object.assign({}, obj1)`的意思是先建立一个空对象{}，接着把`obj1`中所有的属性复制过去，所以`obj2`会长得跟`obj1`一样，这时候再修改`obj2.b`也不会影响`obj1。
```

因为`Object.assign`跟我们手动复制的效果相同，所以一样只能处理深度只有一层的对象，没办法做到真正的 Deep Copy。不过如果要复制的对象只有一层的话可以考虑使用它。

**3、转成 JSON 再转回来**

用`JSON.stringify`把对象转成字符串，再用`JSON.parse`把字符串转成新的对象。

```javascript
var obj1 = { body: { a: 10 } };
var obj2 = JSON.parse(JSON.stringify(obj1));
obj2.body.a = 20;
;console.log(obj1);// { body: { a: 10 } } //沒被改到
console.log(obj2);// { body: { a: 20 } }
console.log(obj1 === obj2);// false
console.log(obj1.body === obj2.body);// false 
//这样做是真正的Deep Copy，这种方法简单易用。
```

但是这种方法也有不少坏处，譬如它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。

这种方法能正确处理的对象只有 `Number, String, Boolean, Array, 扁平对象`，即那些能够被 json 直接表示的数据结构。RegExp对象是无法通过这种方式深拷贝。

也就是说，只有可以转成`JSON`格式的对象才可以这样用，像`function`没办法转成`JSON。`

```javascript
var obj1 = { fun: function(){ console.log(123) } };
var obj2 = JSON.parse(JSON.stringify(obj1));
console.log(typeof obj1.fun);// 'function'
console.log(typeof obj2.fun);// 'undefined', 没复制
```

要复制的`function`会直接消失，所以这个方法只能用在单纯只有数据的对象。

**4、递归拷贝**

```javascript
 function deepClone(initalObj, finalObj) {
        var obj = finalObj || {};
        for (var i in initalObj) {
            if (typeof initalObj[i] === 'object') {
                obj[i] = (initalObj[i].constructor === Array) ? [] : {};
                arguments.callee(initalObj[i], obj[i]);
            } else {
                obj[i] = initalObj[i];
            }
        }
        return obj;
    }

    var str = {};
    var obj = {a: {a: "hello", b: 21}};
    deepClone(obj, str);
    console.log(str.a);
```

上述代码确实可以实现深拷贝。但是当遇到两个互相引用的对象，会出现死循环的情况。

为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否相互引用对象，如果是则退出循环。

改进版代码如下：

```javascript
 function deepClone(initalObj, finalObj) {
        var obj = finalObj || {};
        for (var i in initalObj) {
            var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况  
            if (prop === obj) {
                continue;
            }
            if (typeof prop === 'object') {
                obj[i] = (prop.constructor === Array) ? [] : {};
                arguments.callee(prop, obj[i]);
            } else {
                obj[i] = prop;
            }
        }
        return obj;
    }
    var str = {};
    var obj = {a: {a: "hello", b: 21}};
    deepClone(obj, str);
    console.log(str.a);
```

**5、使用Object.create()方法**

直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。

```javascript
 function deepClone(initalObj, finalObj) {
        var obj = finalObj || {};
        for (var i in initalObj) {
            var prop = initalObj[i];
            // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况   
            if (prop === obj) {
                continue;
            }
            if (typeof prop === 'object') {
                obj[i] = (prop.constructor === Array) ? [] :Object.create(prop);
            } else {
                obj[i] = prop;
            }
        }
        return obj;
    }
```

**6、jquery**

jquery 有提供一个`$.extend`可以用来做 Deep Copy。

```javascript
    var $ = require('jquery');
    var obj1 = {a: 1, b: {f: {g: 1}}, c: [1, 2, 3]};
    var obj2 = $.extend(true, {}, obj1);
    console.log(obj1.b.f === obj2.b.f);// false
```

**7、lodash**

另外一个很热门的函数库lodash，也有提供`_.cloneDeep`用来做 Deep Copy。

```javascript
 	var _ = require('lodash');
    var obj1 = {a: 1, b: {f: {g: 1}}, c: [1, 2, 3]};
    var obj2 = _.cloneDeep(obj1);
    console.log(obj1.b.f === obj2.b.f);// false
```

这个性能还不错，使用起来也很简单。

